<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½çŸ¥è¯†åº“ - Agentic RAG</title>
    <style>
        :root {
            --primary-color: #1262af;
            --secondary-color: #0d4f8c;
            --accent-color: #1262af;
            --text-color: #222;
            --bg-color: #f7fafc;
            --sidebar-width: 250px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            min-height: 100vh;
            overflow: auto; /* å…è®¸é¡µé¢æ•´ä½“æ»šåŠ¨ï¼Œé¿å…å†…å±‚æ»šåŠ¨æ¡ */
        }

        /* Dark theme overrides */
        body.dark {
            --bg-color: #0b1424;
            --text-color: #e5e7eb;
        }
        body.dark .sidebar {
            background: linear-gradient(180deg, #0b2845 0%, #081b2f 100%);
            box-shadow: 2px 0 10px rgba(0,0,0,0.4);
            color: #e5e7eb;
        }
        body.dark .card { background: #0f1b2b; color: var(--text-color); border: 1px solid #1f2937; }
        body.dark input, body.dark select, body.dark textarea {
            background: #0b1220;
            border-color: #1f2937;
            color: var(--text-color);
        }
        body.dark .data-table th { background: #0b1220; color: #e5e7eb; }
        body.dark .data-table td { color: #cbd5e1; }
        body.dark .upload-area { border-color: #1f3b5b; }

        /* Project list */
        .project-block {
            border: 1px solid #e6f3ea;
            border-radius: 10px;
            background: #fff;
            margin-bottom: 14px;
            overflow: hidden;
        }
body.dark .project-block { background: #0c1b2f; border-color: #243447; }
        .project-summary {
            display: flex;
            align-items: center;
            padding: 12px 14px;
            cursor: pointer;
            gap: 12px;
            background: #f3fbf6;
            list-style: none;
        }
        .project-summary::-webkit-details-marker {
            display: none;
        }
        .project-summary .project-info {
            flex: 1;
            min-width: 0;
        }
        .project-summary .project-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: flex-end;
            margin-left: auto;
        }
        .project-summary .project-actions .project-select,
        .project-summary .project-actions .btn {
            flex-shrink: 0;
        }
body.dark .project-summary { background: #102541; }
        .project-summary-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .project-title {
            font-weight: 700;
            color: var(--accent-color);
        }
        body.dark .project-title { color: #8eb4ff; }
        .project-meta {
            color: #718096;
            font-size: 0.9em;
        }
        .project-files {
            padding: 4px 12px 12px 12px;
        }
        .project-progress {
            width: 100%;
            margin-top: 6px;
        }
        .project-progress .progress-track {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 999px;
            overflow: hidden;
        }
        .project-progress .progress-fill {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #48bb78, #38a169);
            transition: width 0.3s ease, background 0.2s ease;
        }
        .project-progress .progress-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 4px;
            color: #4a5568;
            font-size: 0.85em;
        }
body.dark .project-progress .progress-track { background: #1f2937; }
        body.dark .project-progress .progress-meta { color: #cbd5e1; }
        .doc-header,
        .doc-row {
            display: grid;
            grid-template-columns: 40px 1.6fr 110px 180px 170px 110px;
            align-items: center;
            padding: 8px 6px;
        }
        .doc-header {
            font-weight: 600;
            color: #556987;
            border-bottom: 1px solid #e2e8f0;
        }
        .doc-row {
            border-bottom: 1px solid #edf2f7;
        }
        .doc-row:last-child { border-bottom: none; }
        body.dark .doc-row { border-bottom-color: #1f2937; }
        .doc-title {
            font-weight: 600;
            color: #1f3b5b;
        }
        body.dark .doc-title { color: #dce3ff; }
        .doc-name, .doc-time {
            color: #556987;
            font-size: 0.9em;
        }
        body.dark .doc-name, body.dark .doc-time { color: #cbd5e1; }

        /* æ–‡ä»¶çŠ¶æ€ä¸è¿›åº¦ï¼ˆæ±‡ç¼–è¿‡ç¨‹å¯è§†åŒ–ï¼‰ */
        .doc-status {
            display: flex;
            align-items: center;
        }
        .status-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid transparent;
            white-space: nowrap;
        }
        .status-waiting { background: rgba(113,128,150,0.10); color: #4a5568; border-color: rgba(113,128,150,0.25); }
        .status-processing { background: rgba(66,153,225,0.10); color: #2b6cb0; border-color: rgba(66,153,225,0.25); }
        .status-completed { background: rgba(72,187,120,0.10); color: #276749; border-color: rgba(72,187,120,0.25); }
        .status-failed { background: rgba(245,101,101,0.10); color: #c53030; border-color: rgba(245,101,101,0.25); }
        body.dark .status-waiting { background: rgba(203,213,225,0.10); color: #cbd5e1; border-color: rgba(203,213,225,0.25); }
        body.dark .status-processing { background: rgba(99,179,237,0.12); color: #90cdf4; border-color: rgba(99,179,237,0.22); }
        body.dark .status-completed { background: rgba(72,187,120,0.12); color: #9ae6b4; border-color: rgba(72,187,120,0.22); }
        body.dark .status-failed { background: rgba(245,101,101,0.12); color: #feb2b2; border-color: rgba(245,101,101,0.22); }

        .doc-progress {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .file-progress-track {
            flex: 1;
            height: 8px;
            background: #e2e8f0;
            border-radius: 999px;
            overflow: hidden;
        }
        body.dark .file-progress-track { background: #1f2937; }
        .file-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4299e1, #48bb78);
            transition: width 0.25s ease;
        }
        .file-progress-text {
            width: 40px;
            text-align: right;
            font-size: 12px;
            color: #718096;
        }
        body.dark .file-progress-text { color: #cbd5e1; }
        body.dark #doc-list-container {
            background: #0c1b2f !important;
            border-color: #243447 !important;
        }
        body.dark .doc-header { color: #cbd5e1; border-bottom-color: #243447; }
        body.dark .doc-row { border-bottom-color: #243447; }

        /* Select styling */
        .project-select {
            width: 120px;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid #cbd5e0;
            background: #e6f4ff;
            color: #1f3b5b;
            font-size: 0.9em;
        }
        .project-select:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: 1px;
        }
        body.dark .project-select {
            background: #102541;
            border-color: #243447;
            color: #e5e7eb;
        }
        .btn-danger-soft {
            background: rgba(249,115,22,0.08);
            color: #f97316;
            border: 1px solid rgba(249,115,22,0.35);
            box-shadow: none;
        }
        .btn-danger-soft:hover {
            background: rgba(249,115,22,0.15);
            transform: none;
        }
        .btn-danger-soft:active {
            transform: translateY(0);
        }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            background: linear-gradient(180deg, #1262af 0%, #0d4f8c 100%);
            color: white;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.15);
            transition: background 0.3s, color 0.3s;
        }

        .logo {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 40px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-links {
            list-style: none;
            flex: 1;
        }

        .nav-item {
            margin-bottom: 10px;
        }

        .nav-link {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            color: rgba(255,255,255,0.88);
            text-decoration: none;
            border-radius: 10px;
            transition: all 0.25s;
            cursor: pointer;
        }

        .nav-link:hover, .nav-link.active {
            background: rgba(255,255,255,0.18);
            color: white;
            transform: translateX(4px);
        }

        .nav-icon {
            margin-right: 10px;
            font-size: 1.2em;
        }

        .user-profile {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }

        .sidebar-footer {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.15);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .user-info {
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            position: relative;
        }

        .view-section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .view-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .page-header {
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e1e5e9;
        }

        .page-title {
            font-size: 1.8em;
            color: #2d3748;
        }

        /* Cards */
        .card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(15,157,88,0.08);
            margin-bottom: 20px;
            border: 1px solid #e5f4eb;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            border-color: var(--accent-color);
            outline: none;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #0f9d58 0%, #0c7c46 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(15, 157, 88, 0.35);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }
        body.dark .btn-secondary {
            background: #0b1a2e;
            color: #e5e7eb;
            border: 1px solid #243447;
        }
        body.dark .btn-secondary:hover {
            background: #0f2542;
        }

        /* Chat Interface */
        .chat-shell {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: calc(100vh - 220px);
            min-height: 480px;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            background: white;
        }
        body.dark .chat-container {
            background: #0c1b2f;
            border-color: #243447;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
            color: #1f2937;
        }
        body.dark .chat-messages {
            background: #0f1b2b;
            color: #e5e7eb;
        }

        .message {
            margin-bottom: 20px;
            max-width: 80%;
        }

        .message.user {
            margin-left: auto;
            background: #e8f3ff;
            color: #0f172a;
            padding: 12px 18px;
            border-radius: 18px 18px 0 18px;
            border: 1px solid #cbd5e1;
        }
        body.dark .message.user {
            background: #162a42;
            color: #e5e7eb;
            border: 1px solid #243447;
        }

        .message.bot {
            margin-right: auto;
            background: white;
            color: #333;
            padding: 12px 18px;
            border-radius: 18px 18px 18px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        body.dark .message.bot {
            background: #102541;
            color: #e5e7eb;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        }

        .think-panel {
            margin: 6px 0 12px;
            border-radius: 12px;
            border: 1px solid rgba(59, 130, 246, 0.25);
            background: rgba(15, 23, 42, 0.18);
            overflow: hidden;
        }
        body.dark .think-panel {
            border-color: rgba(59, 130, 246, 0.25);
            background: rgba(2, 6, 23, 0.35);
        }
        .think-panel > summary {
            padding: 10px 12px;
            cursor: pointer;
            user-select: none;
            font-weight: 700;
            color: #1e40af;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        body.dark .think-panel > summary {
            color: #60a5fa;
        }
        .think-panel > summary::-webkit-details-marker {
            display: none;
        }
        .think-content {
            margin: 0;
            padding: 10px 12px 12px;
            border-top: 1px solid rgba(148, 163, 184, 0.25);
            white-space: pre-wrap;
            font-size: 0.92em;
            color: #0f172a;
        }
        body.dark .think-content {
            border-top-color: rgba(148, 163, 184, 0.25);
            color: #e5e7eb;
        }

        .msg-actions {
            display: flex;
            gap: 6px;
            justify-content: flex-start;
            margin-top: 8px;
        }
        .msg-action {
            width: 18px;
            height: 18px;
            border-radius: 6px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            cursor: pointer;
            user-select: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s ease, box-shadow 0.2s ease, opacity 0.2s ease;
        }
        .msg-action:hover {
            transform: translateY(-1px);
        }
        .msg-action:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }
        .msg-action svg {
            width: 8px;
            height: 8px;
            color: #fff;
        }
        .msg-action.copy {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            box-shadow: 0 6px 16px rgba(37, 99, 235, 0.25);
        }
        .msg-action.resend {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            box-shadow: 0 6px 16px rgba(22, 163, 74, 0.25);
        }
        body.dark .msg-action.copy,
        body.dark .msg-action.resend {
            border-color: rgba(148, 163, 184, 0.2);
        }

        .chat-input-area {
            padding: 20px;
            background: white;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 10px;
            position: sticky;
            bottom: 0;
        }
        body.dark .chat-input-area {
            background: #0c1b2f;
            border-top-color: #243447;
        }

        .think-block {
            margin-top: 8px;
            background: #f3f4f6;
            border: 1px dashed #cbd5e0;
            border-radius: 8px;
            padding: 10px;
            font-size: 0.92em;
            color: #374151;
            white-space: pre-wrap;
        }
        body.dark .think-block {
            background: #101a2c;
            border-color: #2c3d55;
            color: #e5e7eb;
        }
        .think-toggle {
            padding: 4px 10px;
            font-size: 0.85em;
        }

        /* History drawer */
        .drawer-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.35);
            display: none;
            z-index: 3000;
        }
        .drawer {
            position: fixed;
            top: 0;
            right: -420px;
            width: 380px;
            height: 100vh;
            background: #ffffff;
            box-shadow: -6px 0 20px rgba(0,0,0,0.2);
            padding: 16px;
            transition: right 0.25s ease;
            z-index: 3001;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .drawer.open {
            right: 0;
        }
        body.dark .drawer {
            background: #0c1b2f;
            color: #e5e7eb;
            box-shadow: -6px 0 20px rgba(0,0,0,0.4);
        }
        .history-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 10px;
            background: #f8fafc;
        }
        body.dark .history-list {
            border-color: #243447;
            background: #0f1b2b;
        }
        .history-item {
            padding: 8px 10px;
            border-bottom: 1px solid #e2e8f0;
        }
        .history-item:last-child {
            border-bottom: none;
        }
        body.dark .history-item {
            border-bottom-color: #243447;
        }
        .history-role {
            font-size: 0.85em;
            color: #4a5568;
            margin-bottom: 4px;
        }
        body.dark .history-role {
            color: #cbd5e1;
        }

        /* File Upload */
        .upload-area {
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: var(--accent-color);
            background: #f7fafc;
        }

        .assembly-result {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
        }
        body.dark .assembly-result {
            background: #0f1b2b;
            color: #e5e7eb;
            border: 1px solid #243447;
        }

        /* Tables */
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th, .data-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .data-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #4a5568;
        }

        .status-badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 500;
        }

        .status-pending { background: #feebc8; color: #c05621; }
        .status-approved { background: #c6f6d5; color: #2f855a; }
        .status-rejected { background: #fed7d7; color: #c53030; }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toast {
            background: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin-bottom: 10px;
            border-left: 4px solid var(--accent-color);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Markdown Content Style */
        .markdown-content { line-height: 1.6; }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 { margin-top: 15px; margin-bottom: 10px; color: #2d3748; }
        .markdown-content p { margin-bottom: 10px; }
        .markdown-content ul, .markdown-content ol { margin-left: 20px; margin-bottom: 10px; }
        .markdown-content li { margin-bottom: 5px; }
        .markdown-content pre { background: #f1f1f1; padding: 12px; border-radius: 6px; overflow-x: auto; margin-bottom: 10px; }
        .markdown-content code { background: #edf2f7; padding: 2px 5px; border-radius: 4px; font-family: monospace; color: #c53030; }
        .markdown-content pre code { background: transparent; padding: 0; color: inherit; }
        .markdown-content blockquote { border-left: 4px solid #cbd5e0; padding-left: 15px; color: #718096; margin-bottom: 10px; }
        
        .source-docs { 
            margin-top: 15px; 
            padding: 12px;
            background: #f7fafc;
            border-radius: 8px;
            border: 1px solid #edf2f7;
            font-size: 0.9em;
        }
        body.dark .source-docs {
            background: #0f1b2b;
            border: 1px solid #243447;
        }
        .source-docs-title {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        body.dark .source-docs-title {
            color: #e0e7ff;
        }
        .source-item {
            display: flex;
            gap: 8px;
            margin-bottom: 5px;
            color: #666;
            line-height: 1.5;
        }
        body.dark .source-item {
            color: #94a3b8;
        }
        .source-icon { 
            color: var(--accent-color);
            font-weight: bold;
        }
        body.dark .source-icon {
            color: #60a5fa;
        }

        .source-link {
            color: #1d4ed8;
            text-decoration: underline;
            text-underline-offset: 2px;
            cursor: pointer;
            overflow-wrap: anywhere;
        }
        .source-link:hover { opacity: 0.9; }
        body.dark .source-link {
            color: #93c5fd;
        }

        /* Doc preview drawer */
        .drawer.doc-drawer {
            width: min(72vw, 980px);
            right: -1100px;
        }
        .drawer.doc-drawer.open {
            right: 0;
        }
        .doc-drawer-meta {
            font-size: 0.85em;
            color: #718096;
            margin-top: 2px;
        }
        body.dark .doc-drawer-meta {
            color: #94a3b8;
        }
        .doc-preview-frame {
            width: 100%;
            height: calc(100vh - 120px);
            border: 0;
            border-radius: 10px;
            background: #0b1220;
        }

        /* Smart search */
        .smart-search-bar {
            display: grid;
            grid-template-columns: 150px minmax(260px, 1fr) 92px;
            gap: 10px;
            align-items: center;
            width: 100%;
            max-width: 980px;
            margin-top: 2px;
        }
        .smart-search-bar select,
        .smart-search-bar input {
            padding: 10px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            background: #fff;
            color: #1f2937;
            height: 40px;
            min-width: 0;
        }
        body.dark .smart-search-bar select,
        body.dark .smart-search-bar input {
            background: #0c1b2f;
            border-color: #243447;
            color: #e5e7eb;
        }
        .smart-search-bar .btn {
            height: 40px;
            padding: 0 14px;
            justify-content: center;
        }
        @media (min-width: 1200px) {
            .smart-search-bar {
                grid-template-columns: 160px minmax(360px, 1fr) 96px;
            }
        }
        @media (max-width: 980px) {
            .smart-search-bar {
                grid-template-columns: 1fr;
                width: 100%;
            }
            .smart-search-bar .btn {
                width: 100%;
            }
        }
        .smart-search-results {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 120px;
        }
        .smart-search-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            padding-bottom: 10px;
            margin-bottom: 12px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.25);
        }
        .smart-search-summary {
            color: #718096;
            font-size: 0.9em;
        }
        body.dark .smart-search-summary {
            color: #94a3b8;
        }
        .smart-search-tip {
            color: #64748b;
            font-size: 0.85em;
        }
        body.dark .smart-search-tip {
            color: #94a3b8;
        }
        .search-empty {
            border: 1px dashed rgba(148, 163, 184, 0.35);
            border-radius: 12px;
            padding: 18px;
            text-align: center;
            color: #64748b;
            background: rgba(248, 250, 252, 0.6);
        }
        body.dark .search-empty {
            background: rgba(2, 6, 23, 0.25);
            border-color: rgba(148, 163, 184, 0.22);
            color: #94a3b8;
        }
        .search-empty-title {
            font-weight: 700;
            color: #111827;
            margin-bottom: 6px;
        }
        body.dark .search-empty-title {
            color: #e5e7eb;
        }
        .search-res-card {
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 12px 14px;
            background: #ffffff;
        }
        body.dark .search-res-card {
            background: #0c1b2f;
            border-color: #243447;
        }
        .search-res-title {
            font-weight: 700;
            color: #111827;
            margin-bottom: 8px;
        }
        body.dark .search-res-title {
            color: #e5e7eb;
        }
        .search-res-title a {
            color: inherit;
            text-decoration: none;
        }
        .search-res-title a:hover {
            text-decoration: underline;
            text-underline-offset: 2px;
        }
        .search-res-body {
            color: #334155;
            line-height: 1.6;
            font-size: 0.95em;
        }
        body.dark .search-res-body {
            color: #cbd5e1;
        }
        .search-res-footer {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            font-size: 0.85em;
            color: #64748b;
        }
        body.dark .search-res-footer {
            color: #94a3b8;
        }
        .search-res-tag {
            background: #e2e8f0;
            color: #334155;
            padding: 2px 8px;
            border-radius: 999px;
        }
        body.dark .search-res-tag {
            background: #0b1a2e;
            color: #cbd5e1;
            border: 1px solid #243447;
        }
        .search-pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            gap: 10px;
        }
        .search-pagination .btn { padding: 6px 10px; font-size: 0.85em; }

        /* Assembly Result Pretty Print */
        .json-key { color: #e53e3e; font-weight: bold; }
        .json-string { color: #38a169; }
        .json-number { color: #d69e2e; }
        .json-boolean { color: #3182ce; font-weight: bold; }
        .json-null { color: #718096; font-weight: bold; }
    </style>
</head>
<body>
    <!-- Sidebar -->
        <div class="sidebar">
        <div class="logo" style="display:flex; align-items:center; gap:10px;">
            <img src="image.png" alt="logo" style="width:28px; height:28px; border-radius:6px;"> æ™ºèƒ½çŸ¥è¯†åº“
        </div>
            <ul class="nav-links">
            <li class="nav-item">
                <a class="nav-link active" onclick="switchView('home')">
                    <span class="nav-icon">ğŸ </span> é¦–é¡µ
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link" onclick="switchView('upload')">
                    <span class="nav-icon">ğŸ“¤</span> æ–‡æ¡£ä¸Šä¼ 
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link" onclick="switchView('assembly')">
                    <span class="nav-icon">ğŸ“š</span> çŸ¥è¯†åº“æ„å»º
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link" onclick="switchView('search')">
                    <span class="nav-icon">ğŸ”</span> æ™ºèƒ½æœç´¢
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link" onclick="switchView('chat')">
                    <span class="nav-icon">ğŸ’¬</span> æ™ºèƒ½é—®ç­”
                </a>
            </li>
        </ul>
        <div class="user-profile">
            <div class="user-info" id="current-user-display">æœªç™»å½•</div>
	            <button class="btn btn-secondary" style="width: 100%; font-size: 0.8em;" onclick="showLoginModal(false)">ç™»å½• / åˆ‡æ¢è´¦å·</button>
	        </div>
        <div class="sidebar-footer">
            <button class="btn btn-secondary" style="width: 100%; font-size: 0.85em;" onclick="toggleTheme()">
                <span id="theme-toggle-label-sidebar">ğŸŒ™ å¤œé—´</span>
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="toast-container" id="toast-container"></div>

        <!-- Home View -->
        <div id="view-home" class="view-section active">
            <div class="page-header">
                <h1 class="page-title">æ¬¢è¿ä½¿ç”¨æ™ºèƒ½çŸ¥è¯†åº“</h1>
            </div>
            <div class="card">
                <h3>ğŸ‘‹ å¿«é€Ÿå¼€å§‹</h3>
                <p>è¿™æ˜¯ä¸€ä¸ªåŸºäº Agentic RAG çš„å•é¡µé¢åº”ç”¨ï¼Œæä¾›ä»¥ä¸‹åŠŸèƒ½ï¼ˆç®¡ç†å‘˜å…¥å£ï¼‰ï¼š</p>
                <ul style="margin: 20px; line-height: 1.6;">
                    <li><strong>æ–‡æ¡£ä¸Šä¼ </strong>ï¼šä¸Šä¼ PDFã€Wordç­‰æ–‡æ¡£ï¼Œæ”¯æŒOCRè¯†åˆ«ã€‚</li>
                    <li><strong>çŸ¥è¯†åº“æ„å»º</strong>ï¼šé€‰æ‹©æ–‡æ¡£è¿›è¡Œæ±‡ç¼–ï¼Œè‡ªåŠ¨æå–ç»“æ„åŒ–ä¿¡æ¯ã€‚</li>
                    <li><strong>æ™ºèƒ½é—®ç­”</strong>ï¼šåŸºäºçŸ¥è¯†åº“è¿›è¡Œå¤šè½®å¯¹è¯ï¼Œæ”¯æŒæº¯æºã€‚</li>
                </ul>
            </div>
            <div class="card">
                <h3>ğŸ“Š ç³»ç»ŸçŠ¶æ€</h3>
                <div id="system-status" style="margin-bottom: 15px;">æ£€æŸ¥ä¸­...</div>
                
                <div style="border-top: 1px solid #eee; padding-top: 15px;">
                    <label style="font-size: 0.9em; margin-bottom: 5px;">æ¥å£åœ°å€é…ç½®</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="api-base-input" placeholder="ä¾‹å¦‚: http://localhost:18888" style="flex: 1;">
                        <button class="btn btn-primary" style="padding: 8px 15px; font-size: 0.9em;" onclick="updateApiBase()">ä¿å­˜</button>
                    </div>
                    <p style="font-size: 0.8em; color: #718096; margin-top: 5px;">ä¿®æ”¹åå°†è‡ªåŠ¨åˆ·æ–°é¡µé¢ç”Ÿæ•ˆ</p>
                </div>
            </div>
        </div>

        <!-- Upload View -->
        <div id="view-upload" class="view-section">
            <div class="page-header">
                <h1 class="page-title">æ–‡æ¡£ä¸Šä¼ </h1>
            </div>
            <div class="card">
                <form id="upload-form" onsubmit="handleUpload(event)">
                    <div class="form-group">
                        <label>é¡¹ç›®åç§°</label>
                        <input type="text" id="project-name-input" name="title" required placeholder="è¯·è¾“å…¥é¡¹ç›®åç§°">
                    </div>
                    <div class="form-group">
                        <label>ä¸Šä¼ æ–‡ä»¶ï¼ˆä»»æ„ç±»å‹ï¼Œæ”¯æŒå¤šé€‰ï¼›ZIP å°†è‡ªåŠ¨è§£å‹æ‰å¹³åŒ–ï¼‰</label>
                        <div class="upload-area" id="upload-drop-zone">
                            <p>å¯ç‚¹å‡»æˆ–æ‹–æ‹½ï¼Œé€‰æ‹©ä»»æ„æ•°é‡æ–‡ä»¶</p>
                            <input type="file" id="file-input" name="file" multiple style="display: none" onchange="updateFileName(this)">
                            <p id="file-name-display" style="margin-top: 10px; color: #667eea; font-weight: bold;"></p>
                        </div>
                    </div>
                    <button type="submit" class="btn btn-primary">ğŸš€ å¼€å§‹ä¸Šä¼ </button>
                </form>
            </div>
        </div>

        <!-- Assembly View -->
        <div id="view-assembly" class="view-section">
            <div class="page-header" style="display:flex; align-items:center; justify-content:space-between;">
                <h1 class="page-title">çŸ¥è¯†åº“æ„å»º (æ±‡ç¼–)</h1>
            </div>
            <div class="card">
                <div class="form-group">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; justify-content: flex-start;">
                        <input type="text" id="project-search" placeholder="æœç´¢é¡¹ç›®åç§°ï¼ŒåŒ¹é…é¡¹ç½®é¡¶" style="flex:1; min-width: 240px; max-width: 320px; padding: 8px 10px; border: 1px solid #e2e8f0; border-radius: 8px;" oninput="applyProjectSearch()">
                        <button class="btn btn-secondary" style="padding: 8px 12px; font-size: 0.9em;" onclick="applyProjectSearch()">ğŸ” æœç´¢</button>
                    </div>
                    <div style="border: 1px solid #e2e8f0; padding: 10px; border-radius: 8px; background: #f9fafb;" id="doc-list-container">
                        <p style="text-align: center; color: #999;">åŠ è½½ä¸­...</p>
                    </div>
                    <div id="pagination-container" style="margin-top: 10px;"></div>
                </div>
            </div>
            <div class="card" id="assembly-result-card" style="display: none;">
                <h3>æ„å»ºç»“æœ</h3>
                <pre id="assembly-result" class="assembly-result"></pre>
            </div>
        </div>

        <!-- Smart Search View -->
        <div id="view-search" class="view-section">
            <div class="page-header" style="display:flex; flex-direction:column; align-items:flex-start; gap:12px;">
                <h1 class="page-title">æ™ºèƒ½æœç´¢</h1>
                <div class="smart-search-bar">
                    <select id="smart-search-type" title="æœç´¢ç±»å‹">
                        <option value="1">ç»¼åˆæœç´¢</option>
                        <option value="3">ç²¾ç¡®æœç´¢</option>
                    </select>
                    <input id="smart-search-keyword" type="text" placeholder="è¯·è¾“å…¥å…³é”®å­—" />
                    <button class="btn btn-primary" onclick="performSmartSearch()">æœç´¢</button>
                </div>
            </div>
            <div class="card">
                <div class="smart-search-head">
                    <div id="smart-search-summary" class="smart-search-summary"></div>
                    <div class="smart-search-tip">ç‚¹å‡»ç»“æœæ ‡é¢˜å¯åœ¨å³ä¾§æŠ½å±‰é¢„è§ˆ</div>
                </div>
                <div id="smart-search-results" class="smart-search-results" style="margin-top: 12px;"></div>
                <div class="search-pagination" id="smart-search-pagination" style="display:none;">
                    <button class="btn btn-secondary" id="smart-search-prev" onclick="smartSearchPrev()">ä¸Šä¸€é¡µ</button>
                    <div id="smart-search-page" style="color:#718096;"></div>
                    <button class="btn btn-secondary" id="smart-search-next" onclick="smartSearchNext()">ä¸‹ä¸€é¡µ</button>
                </div>
            </div>
        </div>

        <!-- Chat View -->
        <div id="view-chat" class="view-section">
            <div class="page-header" style="display: flex; justify-content: space-between; align-items: center;">
                <h1 class="page-title">æ™ºèƒ½é—®ç­” (RAG)</h1>
                <div style="display:flex; gap:8px;">
                    <button class="btn btn-secondary" style="font-size: 0.8em; padding: 8px 12px;" onclick="toggleHistoryDrawer(true)">
                        ğŸ“œ å†å²
                    </button>
                    <button class="btn btn-secondary" style="font-size: 0.8em; padding: 8px 15px;" onclick="clearChat()">
                        <span>ğŸ—‘ï¸</span> æ¸…ç©ºå¯¹è¯
                    </button>
                </div>
            </div>
            <div class="chat-shell">
                <div class="chat-container">
                    <div class="chat-messages" id="chat-messages"></div>
                    <div class="chat-input-area">
                        <input type="text" id="chat-input" placeholder="è¯·è¾“å…¥æ‚¨çš„é—®é¢˜..." onkeypress="if(event.key === 'Enter') sendMessage()">
                        <button class="btn btn-primary" onclick="sendMessage()">å‘é€</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- History Drawer -->
        <div class="drawer-overlay" id="history-overlay" onclick="toggleHistoryDrawer(false)"></div>
        <div class="drawer" id="history-drawer">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h3 style="margin:0;">å¯¹è¯å†å²</h3>
                <button class="btn btn-secondary" style="padding:4px 10px; font-size:0.85em;" onclick="toggleHistoryDrawer(false)">å…³é—­</button>
            </div>
            <div class="history-list" id="history-list">
                <p style="color:#718096;">æš‚æ— å†å²è®°å½•</p>
            </div>
        </div>

        <!-- Doc Preview Drawer -->
        <div class="drawer-overlay" id="doc-overlay" onclick="toggleDocDrawer(false)"></div>
        <div class="drawer doc-drawer" id="doc-drawer">
            <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:10px;">
                <div>
                    <h3 id="doc-drawer-title" style="margin:0;">æ–‡æ¡£é¢„è§ˆ</h3>
                    <div id="doc-drawer-meta" class="doc-drawer-meta"></div>
                </div>
                <button class="btn btn-secondary" style="padding:4px 10px; font-size:0.85em;" onclick="toggleDocDrawer(false)">å…³é—­</button>
            </div>
            <iframe id="doc-preview-iframe" class="doc-preview-frame" title="æ–‡æ¡£é¢„è§ˆ"></iframe>
        </div>

    </div>

	    <!-- Login Modal -->
	    <div id="login-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center;">
	        <div class="card" style="width: 400px;">
	            <h3 style="margin-bottom: 12px;">ç™»å½•</h3>
	            <div style="font-size: 0.85em; color: #718096; line-height: 1.4; margin-bottom: 14px;">
	                è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ç™»å½•ã€‚
	            </div>
	            <div class="form-group">
	                <label>ç”¨æˆ·å</label>
	                <input id="login-username" type="text" placeholder="ä¾‹å¦‚ï¼šadmin" autocomplete="username">
	            </div>
	            <div class="form-group">
	                <label>å¯†ç </label>
	                <input id="login-password" type="password" placeholder="è¯·è¾“å…¥å¯†ç " autocomplete="current-password" onkeypress="if(event.key === 'Enter') performLogin()">
	            </div>
	            <button class="btn btn-primary" style="width: 100%;" onclick="performLogin()">ç™»å½•</button>
	            <button id="login-cancel-btn" class="btn btn-secondary" style="width: 100%; margin-top: 10px;" onclick="hideLoginModal()">å–æ¶ˆ</button>
	        </div>
	    </div>

    <!-- Delete Confirm Modal -->
    <div id="delete-confirm-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center;">
        <div class="card" style="width: 380px; text-align: center;">
            <h3 style="margin-bottom: 15px;">âš ï¸ ç¡®è®¤åˆ é™¤</h3>
            <p id="delete-confirm-msg" style="margin-bottom: 20px; color: #4a5568;">ç¡®å®šåˆ é™¤è¯¥æ–‡æ¡£?</p>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="btn btn-secondary" style="flex: 1;" onclick="cancelDelete()">å–æ¶ˆ</button>
                <button class="btn btn-primary" style="flex: 1; background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);" onclick="confirmDelete()">åˆ é™¤</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = resolveApiBase();
        let CURRENT_TOKEN = localStorage.getItem('jwt_token');
        let CURRENT_USER = JSON.parse(localStorage.getItem('user_info') || 'null');

        function resolveApiBase() {
            // Priority: query param override -> localStorage -> global override -> smart default
            const params = new URLSearchParams(window.location.search);
            const override = params.get('api_base') || params.get('api');
            if (override) {
                const clean = sanitizeBase(override);
                localStorage.setItem('rag_api_base', clean);
                return clean;
            }

            // Check localStorage first!
            const stored = localStorage.getItem('rag_api_base');
            if (stored) return sanitizeBase(stored);

            const defaultBase = 'http://localhost:18888';
            const origin = window.location.origin || '';
            const port = window.location.port || '';
            const protocol = window.location.protocol || '';

            const isHttp = protocol.startsWith('http');
            const isFileLike = protocol === 'file:';
            const isAppScheme = protocol.startsWith('app') || origin.startsWith('app://') || origin.startsWith('tauri://');
            const isDevStatic = port === '5180' ||
                origin.includes('localhost:5180') ||
                origin.includes('0.0.0.0:5180') ||
                origin.includes('127.0.0.1:5180');

            // å¯¹äºé http/https æˆ– dev é™æ€æœï¼Œå¼ºåˆ¶é»˜è®¤åç«¯
            if (!isHttp || isFileLike || isAppScheme || isDevStatic) {
                return defaultBase;
            }

            if (window.API_BASE_OVERRIDE) return sanitizeBase(window.API_BASE_OVERRIDE);

            // å…¶ä»–æƒ…å†µç”¨å½“å‰æº
            return sanitizeBase(origin);
        }

	        function sanitizeBase(base) {
            if (!base) return '';
            const trimmed = base.endsWith('/') ? base.slice(0, -1) : base;
            // é˜²æ­¢æ— åè®®æˆ–éæ³• scheme å¯¼è‡´ URL æ„é€ æŠ¥é”™
            if (!/^https?:\/\//i.test(trimmed)) {
                return 'http://localhost:18888';
            }
            return trimmed;
	        }

	        let CURRENT_THEME = localStorage.getItem('rag_theme') || 'light';

	        // Initialization
	        document.addEventListener('DOMContentLoaded', () => {
	            document.getElementById('api-base-input').value = API_BASE;
	            // é¦–æ¬¡æ‰“å¼€å®¢æˆ·ç«¯ï¼šå¿…é¡»æ˜¾å¼ç™»å½•ï¼ˆä¸å†è‡ªåŠ¨ç”Ÿæˆæ¨¡æ‹Ÿ tokenï¼‰
	            if (CURRENT_TOKEN) {
	                refreshCurrentUser().then((ok) => {
	                    if (!ok) showLoginModal(true);
	                    checkHealth();
	                });
	            } else {
	                showLoginModal(true);
	                checkHealth();
	            }

	            applyTheme(CURRENT_THEME);
	            // åˆå§‹æ¬¢è¿è¯­ï¼ˆä¸è®¡å…¥å†å²ï¼‰
	            addMessage('ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„æ™ºèƒ½åŠ©æ‰‹ã€‚è¯·é—®æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®ä½ çš„å—ï¼Ÿæ‚¨å¯ä»¥è¯¢é—®å…³äºå·²ä¸Šä¼ æ–‡æ¡£çš„å†…å®¹ã€‚', 'bot', false, '', false);
	        });

        // Navigation
        function switchView(viewId) {
            document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
            document.getElementById('view-' + viewId).classList.add('active');
            
            document.querySelectorAll('.nav-link').forEach(el => el.classList.remove('active'));
            event.currentTarget.classList.add('active');

            if (viewId === 'assembly') loadMyDocuments();
            if (viewId === 'upload') setupDragAndDrop();
        }

	        // Auth Functions
	        function showLoginModal(force = false) {
	            const modal = document.getElementById('login-modal');
	            const cancelBtn = document.getElementById('login-cancel-btn');
	            if (cancelBtn) cancelBtn.style.display = force ? 'none' : 'block';
	            modal.style.display = 'flex';
	            // Prefill username if we have previous info
	            const u = document.getElementById('login-username');
	            if (u && !u.value) u.value = (CURRENT_USER && CURRENT_USER.user_name) ? CURRENT_USER.user_name : '';
	            const p = document.getElementById('login-password');
	            if (p) p.value = '';
	            setTimeout(() => (u ? u.focus() : null), 50);
	        }

	        function hideLoginModal() {
	            const modal = document.getElementById('login-modal');
	            if (modal) modal.style.display = 'none';
	        }

	        async function refreshCurrentUser() {
	            if (!CURRENT_TOKEN) return false;
	            try {
	                const infoRes = await apiFetch('/auth/users/me', { headers: getHeaders() });
	                if (infoRes.status === 401) return false;
	                const infoData = await infoRes.json().catch(() => null);
	                if (!infoRes.ok || !infoData || !infoData.user_id) return false;
	                CURRENT_USER = infoData;
	                USER_ID = infoData.user_id;
	                localStorage.setItem('user_info', JSON.stringify(CURRENT_USER));
	                updateUserDisplay();
	                return true;
	            } catch (e) {
	                return false;
	            }
	        }

	        async function performLogin() {
	            const username = (document.getElementById('login-username')?.value || '').trim();
	            const password = document.getElementById('login-password')?.value || '';
	            if (!username) return showToast('è¯·è¾“å…¥ç”¨æˆ·å', 'error');
	            if (!password) return showToast('è¯·è¾“å…¥å¯†ç ', 'error');

	            try {
	                const body = new URLSearchParams();
	                body.set('grant_type', 'password');
	                body.set('username', username);
	                body.set('password', password);
	                body.set('scope', '');

	                const response = await apiFetch('/auth/token', {
	                    method: 'POST',
	                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
	                    body
	                });

	                if (!response.ok) {
	                    if (response.status === 401) {
	                        showToast('ç™»å½•å¤±è´¥ï¼šç”¨æˆ·åæˆ–å¯†ç é”™è¯¯ï¼ˆå¦‚é¦–æ¬¡éƒ¨ç½²å°šæœªåˆ›å»ºè´¦å·ï¼Œè¯·å…ˆæŒ‰ readme.txt æ‰§è¡Œåˆå§‹åŒ– curlï¼‰', 'error');
	                        return;
	                    }
	                    const err = await response.text().catch(() => '');
	                    throw new Error(err || `HTTP ${response.status}`);
	                }

	                const data = await response.json().catch(() => ({}));
	                CURRENT_TOKEN = data.access_token;
	                CURRENT_USER = data.user_info || { user_name: username };

	                localStorage.setItem('jwt_token', CURRENT_TOKEN);
	                localStorage.setItem('user_info', JSON.stringify(CURRENT_USER));

	                await refreshCurrentUser();
	                hideLoginModal();
	                showToast('ç™»å½•æˆåŠŸ', 'success');
	                checkHealth();
	            } catch (e) {
	                showToast('ç™»å½•å¤±è´¥: ' + e.message, 'error');
	            }
	        }

	        function updateUserDisplay() {
	            if (CURRENT_USER) {
	                const deptName = CURRENT_USER.dept_name || (CURRENT_USER.dept_id ? `éƒ¨é—¨ID: ${CURRENT_USER.dept_id}` : 'æœªè®¾ç½®éƒ¨é—¨');
	                const nick = CURRENT_USER.nick_name || CURRENT_USER.user_name || 'å·²ç™»å½•';
	                document.getElementById('current-user-display').innerHTML = `
	                    <strong>${nick}</strong><br>
	                    ${deptName}
	                `;
	            }
	        }

        // Utils
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.style.borderLeftColor = type === 'error' ? '#f56565' : (type === 'success' ? '#48bb78' : '#4facfe');
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function buildUrl(path) {
            if (path.startsWith('http')) return path;
            return `${API_BASE}${path}`;
        }

        function apiFetch(path, options = {}) {
            return fetch(buildUrl(path), options);
        }

        function getHeaders(extra = {}) {
            const headers = { ...extra };
            if (CURRENT_TOKEN) {
                headers['Authorization'] = `Bearer ${CURRENT_TOKEN}`;
            }
            return headers;
        }

	        function forceRelogin(message = 'è¯·é‡æ–°ç™»å½•') {
	            localStorage.removeItem('jwt_token');
	            localStorage.removeItem('user_info');
	            CURRENT_TOKEN = null;
	            CURRENT_USER = null;
	            showLoginModal(true);
	            showToast(message, 'error');
	        }

        function applyTheme(theme) {
            document.body.classList.toggle('dark', theme === 'dark');
            CURRENT_THEME = theme;
            localStorage.setItem('rag_theme', theme);
            const labelSidebar = document.getElementById('theme-toggle-label-sidebar');
            if (labelSidebar) labelSidebar.textContent = theme === 'dark' ? 'â˜€ï¸ æ—¥é—´' : 'ğŸŒ™ å¤œé—´';
        }

        function toggleTheme() {
            const next = CURRENT_THEME === 'dark' ? 'light' : 'dark';
            applyTheme(next);
        }

        // Think tag handling
        function extractThink(text) {
            if (!text) return { visible: text, think: null };
            const regex = /<think>([\s\S]*?)<\/think>/i;
            const match = regex.exec(text);
            if (match) {
                const think = match[1].trim();
                const visible = text.replace(regex, '').trim();
                return { visible, think };
            }
            return { visible: text, think: null };
        }

        function toggleThink(id) {
            const el = document.getElementById(id);
            if (!el) return;
            const isHidden = el.style.display === 'none' || !el.style.display;
            el.style.display = isHidden ? 'block' : 'none';
        }
        
        const CHAT_HISTORY = [];
        let REMOTE_HISTORY = [];
        let USER_ID = null;

        function toggleHistoryDrawer(open) {
            const drawer = document.getElementById('history-drawer');
            const overlay = document.getElementById('history-overlay');
            if (open) {
                loadRemoteHistory().finally(() => renderHistory());
                renderHistory(); // å…ˆç”¨æœ¬åœ°çš„å±•ç¤º
                drawer.classList.add('open');
                overlay.style.display = 'block';
            } else {
                drawer.classList.remove('open');
                overlay.style.display = 'none';
            }
        }

        function renderHistory() {
            const list = document.getElementById('history-list');
            const blocks = [];
            
            // Remote History
            if (REMOTE_HISTORY.length) {
                blocks.push(`<div style="font-weight:700; margin-bottom:6px;">äº‘ç«¯å†å²</div>`);
                
                // Group conversations by proximity in time (sessions)
                const sessions = [];
                let currentSession = [];
                
                // Sort by time ascending first to process
                const sorted = [...REMOTE_HISTORY].sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                
                sorted.forEach((msg, i) => {
                    if (i === 0) {
                        currentSession.push(msg);
                        return;
                    }
                    
                    const prev = sorted[i-1];
                    const timeDiff = new Date(msg.created_at) - new Date(prev.created_at);
                    // Group messages within 5 minutes of each other
                    if (timeDiff < 5 * 60 * 1000) {
                        currentSession.push(msg);
                    } else {
                        if (currentSession.length > 0) sessions.push(currentSession);
                        currentSession = [msg];
                    }
                });
                if (currentSession.length > 0) sessions.push(currentSession);
                
                // Reverse sessions to show newest first
                sessions.reverse().forEach((session, idx) => {
                    // Find first user question in session
                    const userMsg = session.find(m => m.role === 'user');
                    const summary = userMsg ? userMsg.summary : '(æ— æé—®)';
                    const time = new Date(session[0].created_at).toLocaleString();
                    // Store session data in data attribute for restoration
                    const sessionData = encodeURIComponent(JSON.stringify(session));
                    
                    blocks.push(`
                        <div class="history-item" onclick="restoreSession(this)" data-session="${sessionData}" style="cursor:pointer;">
                            <div class="history-role">${time} Â· ä¼šè¯ ${sessions.length - idx}</div>
                            <div style="font-size:0.95em; color:#1f2937;">${summary}</div>
                        </div>
                    `);
                });
            }
            
            // Local History (current active session)
            if (CHAT_HISTORY.length) {
                blocks.push(`<div style="font-weight:700; margin:8px 0 6px 0;">å½“å‰ä¼šè¯</div>`);
                // We don't render individual messages here anymore to avoid clutter,
                // or we could render just a summary "Active Session"
                const lastUserMsg = [...CHAT_HISTORY].reverse().find(m => m.role === 'user');
                const summary = lastUserMsg ? lastUserMsg.content : '(å¯¹è¯è¿›è¡Œä¸­)';
                blocks.push(`
                    <div class="history-item" style="background:#e6fffa; border-left:3px solid #38b2ac;" onclick="toggleHistoryDrawer(false)">
                        <div class="history-role">æ­£åœ¨è¿›è¡Œ</div>
                        <div style="font-size:0.95em; color:#1f2937;">${summary.substring(0, 50)}${summary.length>50?'...':''}</div>
                    </div>
                `);
            }
            
            if (!blocks.length) {
                list.innerHTML = '<p style="color:#718096;">æš‚æ— å†å²è®°å½•</p>';
            } else {
                list.innerHTML = blocks.join('');
            }
        }

        function restoreSession(el) {
            // if (!confirm('æ¢å¤å†å²ä¼šè¯å°†æ¸…ç©ºå½“å‰æœªä¿å­˜çš„å¯¹è¯ç•Œé¢ï¼Œç¡®å®šå—ï¼Ÿ')) return;
            
            try {
                const sessionData = JSON.parse(decodeURIComponent(el.dataset.session));
                const container = document.getElementById('chat-messages');
                container.innerHTML = '';
                CHAT_HISTORY.length = 0; // Clear local history tracking
                
                // Initial greeting
                addMessage('ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„æ™ºèƒ½åŠ©æ‰‹ã€‚è¯·é—®æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®ä½ çš„å—ï¼Ÿæ‚¨å¯ä»¥è¯¢é—®å…³äºå·²ä¸Šä¼ æ–‡æ¡£çš„å†…å®¹ã€‚', 'bot', false, '', false);
                
                let lastUserQuestion = '';
                // Replay session messages
                sessionData.forEach(msg => {
                    // Map 'assistant' from backend to 'bot' for frontend logic if needed, 
                    // but addMessage handles 'assistant' via CHAT_HISTORY push logic 
                    // strictly speaking addMessage takes 'user' or 'bot' as types for styling.
                    const type = msg.role === 'user' ? 'user' : 'bot';
                    
                    // For bot messages, we might want to render HTML if it was saved that way,
                    // but currently our saveConversation saves the raw content.
                    // Since we use SimpleMarkdown.parse in addMessage, plain text is fine.
                    
                    // Extract think blocks if present in history content (unlikely for now but good for future)
                    let content = msg.summary; // In loadRemoteHistory we mapped content -> summary
                    
                    // If it's bot, handle think tags
                    if (type === 'bot') {
                        const { visible, think } = extractThink(content);
                        content = visible;
                        const botId = addMessage(content, type, true, '', true);
                        const botEl = document.getElementById(botId);
                        if (botEl) {
                            if (lastUserQuestion) botEl.dataset.question = lastUserQuestion;
                            if (think) setThinkPanel(botEl, think, { placeholder: false });
                            ensureBotActions(botEl);
                            setBotActionsEnabled(botEl, true);
                        }
                        return;
                    }
                    
                    if (type === 'user') {
                        addMessage(content, type, false, '', true);
                        lastUserQuestion = content;
                    }
                });
                
                toggleHistoryDrawer(false);
                showToast('å·²åŠ è½½å†å²ä¼šè¯', 'success');
                
            } catch (e) {
                console.error(e);
                showToast('åŠ è½½ä¼šè¯å¤±è´¥', 'error');
            }
        }

        async function loadRemoteHistory() {
            try {
                // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯ï¼ˆä¸€æ¬¡æ€§ï¼‰
                if (!USER_ID) {
                    const infoRes = await apiFetch('/auth/users/me', { headers: getHeaders() });
                    const infoData = await infoRes.json();
                    if (infoRes.ok && infoData.user_id) {
                        USER_ID = infoData.user_id;
                    }
                }
                if (!USER_ID) return;

                const res = await apiFetch(`/auth/conversations/${USER_ID}?limit=50&skip=0`, {
                    headers: getHeaders()
                });
                const data = await res.json();
                if (res.status === 401) {
                    forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                    return;
                }
                if (res.ok && Array.isArray(data)) {
                    REMOTE_HISTORY = data.map(c => ({
                        id: c.id,
                        created_at: c.timestamp || c.created_at,
                        summary: c.content || '(æ— æé—®)',
                        role: c.role
                    }));
                }
            } catch (e) {
                console.warn('åŠ è½½è¿œç¨‹å†å²å¤±è´¥', e);
            }
        }

        // API Features
        function updateApiBase() {
            const input = document.getElementById('api-base-input');
            let newBase = input.value.trim();
            
            if (!newBase) {
                if(confirm('ç¡®å®šè¦æ¢å¤é»˜è®¤æ¥å£åœ°å€å—ï¼Ÿ')) {
                    localStorage.removeItem('rag_api_base');
                    location.reload();
                }
                return;
            }
            
            // Basic validation and auto-fix
            if (!/^https?:\/\//i.test(newBase)) {
                if (newBase.includes('localhost') || newBase.match(/^\d{1,3}\./)) {
                    newBase = 'http://' + newBase;
                } else {
                    return showToast('æ¥å£åœ°å€å¿…é¡»ä»¥ http:// æˆ– https:// å¼€å¤´', 'error');
                }
            }
            
            // Remove trailing slash
            if (newBase.endsWith('/')) newBase = newBase.slice(0, -1);
            
            if (newBase === API_BASE) return showToast('åœ°å€æœªå‘ç”Ÿå˜åŒ–', 'info');

            localStorage.setItem('rag_api_base', newBase);
            showToast('æ¥å£åœ°å€å·²æ›´æ–°ï¼Œæ­£åœ¨åˆ·æ–°...', 'success');
            setTimeout(() => location.reload(), 800);
        }

        async function checkHealth() {
            try {
                const res = await apiFetch('/health');
                const data = await res.json();
                document.getElementById('system-status').innerHTML = 
                    `æ¥å£: ${API_BASE || 'å½“å‰æº'} Â· çŠ¶æ€: <span class="status-badge status-approved">${data.data.status}</span>`;
            } catch (e) {
                document.getElementById('system-status').innerHTML = `æ¥å£: ${API_BASE || 'å½“å‰æº'} Â· çŠ¶æ€: è¿æ¥å¤±è´¥`;
            }
        }

        function updateFileName(input) {
            if (input.files.length > 0) {
                const names = Array.from(input.files).map(f => f.name);
                document.getElementById('file-name-display').textContent = 'å·²é€‰æ‹©: ' + names.join(', ');
                const projectInput = document.getElementById('project-name-input');
                if (projectInput && !projectInput.value.trim()) {
                    const baseName = names[0].replace(/\.[^/.]+$/, '');
                    projectInput.value = baseName;
                }
            }
        }

        function setupDragAndDrop() {
            const dropZone = document.getElementById('upload-drop-zone');
            const fileInput = document.getElementById('file-input');
            
            if (dropZone.dataset.dndInit) return; // Prevent duplicate listeners
            
            dropZone.addEventListener('click', () => fileInput.click());
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            function highlight(e) {
                dropZone.style.borderColor = 'var(--accent-color)';
                dropZone.style.background = '#f7fafc';
            }

            function unhighlight(e) {
                dropZone.style.borderColor = '#cbd5e0';
                dropZone.style.background = 'transparent';
            }

            dropZone.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (!files || !files.length) return;
                const buffer = new DataTransfer();
                Array.from(files).forEach(f => buffer.items.add(f)); // å…¨éƒ¨ä¿ç•™
                fileInput.files = buffer.files;
                updateFileName(fileInput);
            }
            
            dropZone.dataset.dndInit = 'true';
        }

        // Upload
        async function handleUpload(e) {
            e.preventDefault();
            const projectName = document.getElementById('project-name-input').value.trim();
            const fileInput = document.getElementById('file-input');
            if (!projectName) return showToast('è¯·è¾“å…¥é¡¹ç›®åç§°', 'error');
            if (!fileInput.files.length) return showToast('è¯·é€‰æ‹©æ–‡ä»¶', 'error');

            const files = Array.from(fileInput.files);
            const zipFiles = files.filter(f => f.name.toLowerCase().endsWith('.zip'));
            const otherFiles = files.filter(f => !f.name.toLowerCase().endsWith('.zip'));

            const deptId = (CURRENT_USER && CURRENT_USER.dept_id) ? CURRENT_USER.dept_id : 100;
            
            try {
                let successCount = 0;
                let failed = [];

                if (otherFiles.length) {
                    showToast(`æ­£åœ¨ä¸Šä¼  ${otherFiles.length} ä¸ªæ–‡ä»¶...`, 'info');
                    const formData = new FormData();
                    formData.append('title', projectName);
                    formData.append('department_id', deptId);
                    formData.append('description', '');
                    otherFiles.forEach(f => formData.append('files', f));

                    const res = await apiFetch('/api/documents/upload-multi', {
                        method: 'POST',
                        headers: getHeaders(), // FormData doesn't need Content-Type
                        body: formData
                    });
                    const data = await res.json();
                    if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                    if (!(res.ok && data.code === 200)) {
                        throw new Error(data.msg || 'ä¸Šä¼ å¤±è´¥');
                    }
                    successCount += data?.data?.success || 0;
                    failed = failed.concat(data?.data?.failed || []);
                }

                if (zipFiles.length) {
                    for (const zip of zipFiles) {
                        showToast(`æ­£åœ¨ä¸Šä¼ å¹¶è§£å‹: ${zip.name}`, 'info');
                        const formData = new FormData();
                        formData.append('title', projectName);
                        formData.append('department_id', deptId);
                        formData.append('file', zip);
                        formData.append('description', '');

                        const res = await apiFetch('/api/documents/upload-zip', {
                            method: 'POST',
                            headers: getHeaders(),
                            body: formData
                        });
                        const data = await res.json();
                        if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                        if (!(res.ok && data.code === 200)) {
                            failed.push(zip.name + ': ' + (data.msg || 'ä¸Šä¼ å¤±è´¥'));
                        } else {
                            const count = data?.data?.files?.length || 1;
                            successCount += count;
                        }
                    }
                }

                if (failed.length) {
                    showToast(`éƒ¨åˆ†å¤±è´¥: ${failed.join('ï¼›')}`, 'error');
                }
                if (successCount > 0) {
                    showToast(`ä¸Šä¼ æˆåŠŸï¼Œå¤„ç† ${successCount} ä¸ªæ–‡ä»¶`, 'success');
                }

                e.target.reset();
                document.getElementById('file-name-display').textContent = '';
                document.getElementById('project-name-input').value = '';
            } catch (err) {
                showToast('ä¸Šä¼ å¤±è´¥: ' + err.message, 'error');
            }
        }

        // Assembly
        let ALL_DOCS = [];
        let SELECTED_DOCS = new Set();
        let PROJECT_GROUPS = {};
        const PROJECT_TOP_K = 5;
        let ASSEMBLY_ACTION = 'ç ”ç©¶æ¡£æ¡ˆ';
        const PAGE_SIZE = 12; // æ§åˆ¶æ¯é¡µé¡¹ç›®æ•°ï¼Œä¾¿äºæŠ½å±‰å±•ç¤º
        let CURRENT_PAGE = 1;
        const PROJECT_ASSEMBLY_STATE = {}; // projectKey -> { status, progress, taskId, error, queue_position }
        const ASSEMBLY_POLLERS = {}; // taskId -> intervalId
        const PROJECT_STATUS_LABELS = {
            queued: 'æ’é˜Ÿä¸­',
            running: 'å¤„ç†ä¸­',
            completed: 'å·²å®Œæˆ',
            failed: 'å¤„ç†å¤±è´¥',
            cancelled: 'å·²å–æ¶ˆ',
            timeout: 'è¶…æ—¶'
        };
        let MSG_COUNTER = 0;

        // æ–‡ä»¶çº§è¿›åº¦å±•ç¤ºï¼ˆç¡®è®¤ä¸åç«¯ä¸€è‡´ï¼šwaiting/processing/completed/failedï¼‰
        const FILE_STATUS_LABELS = {
            waiting: 'ç­‰å¾…ä¸­',
            processing: 'å¤„ç†ä¸­',
            completed: 'å·²å®Œæˆ',
            failed: 'å¤±è´¥'
        };
        // å¤ç”¨ tasks.vue çš„ SSE åè®®ï¼šè¿æ¥ /tasks/stream åæŒ‰ task_id è¿‡æ»¤
        let TASKS_STREAM_SOURCE = null;
        const TASKS_STREAM_SUBS = {}; // taskId -> projectName

        function toJsonUrl(filePath) {
            try {
                const raw = decodeURIComponent(String(filePath || ''));
                const noQuery = raw.split('?')[0].split('#')[0];
                if (noQuery.toLowerCase().endsWith('.json')) return noQuery;
                const idx = noQuery.lastIndexOf('.');
                if (idx > -1) return noQuery.slice(0, idx) + '.json';
                return noQuery + '.json';
            } catch (e) {
                const s = String(filePath || '');
                if (s.toLowerCase().endsWith('.json')) return s;
                const idx = s.lastIndexOf('.');
                if (idx > -1) return s.slice(0, idx) + '.json';
                return s + '.json';
            }
        }

        function getFileBadgeClass(status) {
            switch (status) {
                case 'processing': return 'status-processing';
                case 'completed': return 'status-completed';
                case 'failed': return 'status-failed';
                case 'waiting':
                default: return 'status-waiting';
            }
        }

        function renderFileStatusBadge(status) {
            const s = status || 'waiting';
            const text = FILE_STATUS_LABELS[s] || s;
            const cls = getFileBadgeClass(s);
            return `<span class="status-badge ${cls}">${text}</span>`;
        }

        function updateDocProgressRow(docId, fp) {
            const statusEl = document.getElementById(`doc-status-${docId}`);
            const fillEl = document.getElementById(`doc-progress-fill-${docId}`);
            const textEl = document.getElementById(`doc-progress-text-${docId}`);
            if (!statusEl || !fillEl || !textEl) return;
            const status = (fp && fp.status) ? fp.status : 'waiting';
            const progress = Math.min(100, Math.max(0, Number(fp && fp.progress) || 0));
            statusEl.innerHTML = renderFileStatusBadge(status);
            fillEl.style.width = `${progress}%`;
            textEl.textContent = `${progress}%`;
        }

        function refreshProjectFileProgress(projectName) {
            const key = getProjectKey(projectName);
            const state = PROJECT_ASSEMBLY_STATE[key] || {};
            const fpMap = state.file_progress || {};
            const selected = new Set(state.selected_urls || []);

            Object.entries(PROJECT_GROUPS).forEach(([pid, group]) => {
                if (getProjectKey(group.name) !== key) return;
                group.docs.forEach(doc => {
                    const inTask = selected.size ? selected.has(doc.file_path) : true;
                    if (!inTask) {
                        updateDocProgressRow(doc.id, { status: 'waiting', progress: 0 });
                        return;
                    }
                    const jsonUrl = toJsonUrl(doc.file_path);
                    const fp = fpMap[jsonUrl] || { status: 'waiting', progress: 0 };
                    updateDocProgressRow(doc.id, fp);
                });
            });
        }

        function ensureTasksStreamConnected() {
            if (TASKS_STREAM_SOURCE) return;
            const token = CURRENT_TOKEN || localStorage.getItem('jwt_token');
            const url = buildUrl(`/tasks/stream?token=${encodeURIComponent(token || '')}`);
            const es = new EventSource(url);
            TASKS_STREAM_SOURCE = es;

            es.onmessage = function (event) {
                try {
                    const payload = JSON.parse(event.data || '{}');
                    if (payload.error) return;
                    const tasks = Array.isArray(payload.tasks) ? payload.tasks : [];
                    if (!tasks.length) return;

                    // æ„å»ºç´¢å¼•ï¼ŒåŠ é€ŸæŸ¥æ‰¾
                    const byId = {};
                    tasks.forEach(t => { if (t && t.task_id) byId[t.task_id] = t; });

                    Object.entries(TASKS_STREAM_SUBS).forEach(([taskId, projectName]) => {
                        const t = byId[taskId];
                        if (!t) return;

                        const status = t.status || 'running';
                        const progress = status === 'completed' ? 100 : (typeof t.progress === 'number' ? t.progress : 0);
                        updateProjectAssemblyState(projectName, {
                            status,
                            progress,
                            taskId,
                            error: t.error || null,
                            queue_position: t.queue_position ?? -1,
                            estimated_wait: t.estimated_wait ?? 0,
                            file_progress: t.file_progress || {},
                            agent_progress: t.agent_progress || {}
                        });
                        refreshAssemblyUIForProject(projectName);
                        refreshProjectFileProgress(projectName);

                        if (status === 'completed') {
                            showToast('æ±‡ç¼–å®Œæˆ', 'success');
                            loadMyDocuments();
                            delete TASKS_STREAM_SUBS[taskId];
                        } else if (['failed', 'cancelled', 'timeout'].includes(status)) {
                            showToast('æ±‡ç¼–å¤±è´¥: ' + (t.error || 'æœªçŸ¥é”™è¯¯'), 'error');
                            delete TASKS_STREAM_SUBS[taskId];
                        }
                    });

                    // æ— è®¢é˜…æ—¶å…³é—­ SSEï¼Œå‡å°‘è¿æ¥
                    if (Object.keys(TASKS_STREAM_SUBS).length === 0) {
                        try { es.close(); } catch (e) {}
                        TASKS_STREAM_SOURCE = null;
                    }
                } catch (e) {
                    // ignore
                }
            };

            es.onerror = function () {
                // EventSource ä¼šè‡ªåŠ¨é‡è¿ï¼›è‹¥æ²¡æœ‰è®¢é˜…åˆ™å…³é—­
                if (Object.keys(TASKS_STREAM_SUBS).length === 0) {
                    try { es.close(); } catch (e) {}
                    TASKS_STREAM_SOURCE = null;
                }
            };
        }

        function setAssemblyType(val) {
            ASSEMBLY_ACTION = val || 'é¡¹ç›®æ¡£æ¡ˆ';
        }

        function nextMsgId() {
            MSG_COUNTER += 1;
            return `msg-${Date.now().toString(36)}-${MSG_COUNTER}`;
        }

        function getProjectKey(name) {
            return (name || 'æœªåˆ†ç»„é¡¹ç›®').trim();
        }

        function getProjectAssemblyState(projectName) {
            return PROJECT_ASSEMBLY_STATE[getProjectKey(projectName)];
        }

        function updateProjectAssemblyState(projectName, patch) {
            const key = getProjectKey(projectName);
            const prev = PROJECT_ASSEMBLY_STATE[key] || {};
            PROJECT_ASSEMBLY_STATE[key] = { ...prev, ...patch, projectName };
        }

        function getProgressColor(status) {
            if (status === 'failed') return '#f56565';
            if (status === 'completed') return '#48bb78';
            return '#4299e1';
        }

        function renderProjectAssemblyStatus(projectName, pid) {
            const container = document.getElementById(`project-progress-${pid}`);
            const state = getProjectAssemblyState(projectName);
            
            // Update Button State
            const btn = document.getElementById(`assembly-btn-${pid}`);
            if (btn) {
                const status = state ? (state.status || 'running') : 'running';
                const isCompleted = status === 'completed';
                btn.textContent = isCompleted ? 'é‡æ–°æ±‡ç¼–' : 'æ±‡ç¼–é¡¹ç›®';
                
                // Apply optimized styles
                btn.style.padding = '7px 18px';
                btn.style.fontSize = '0.85em';
                btn.style.fontWeight = '600';
                btn.style.minWidth = '100px';
                btn.style.borderRadius = '20px';
                btn.style.border = 'none';
                btn.style.color = 'white';
                btn.style.letterSpacing = '0.5px';
                btn.style.transition = 'all 0.2s';

                if (isCompleted) {
                    btn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
                    btn.style.boxShadow = '0 4px 12px rgba(245, 158, 11, 0.3)';
                } else {
                    btn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                    btn.style.boxShadow = '0 4px 12px rgba(16,185,129,0.3)';
                }
            }

            if (!container) return;
            if (!state) {
                container.style.display = 'none';
                return;
            }
            const status = state.status || 'running';
            // å¦‚æœå·²å®Œæˆï¼Œå¼ºåˆ¶æ˜¾ç¤º100%ï¼›å¦‚æœå¤±è´¥ï¼Œæ˜¾ç¤º0%
            let progressVal = typeof state.progress === 'number' ? Math.min(Math.max(state.progress, 0), 100) : 0;
            if (status === 'completed') {
                progressVal = 100;
            } else if (status === 'failed') {
                progressVal = 0;
            }
            const color = getProgressColor(status);
            const statusText = PROJECT_STATUS_LABELS[status] || 'å¤„ç†ä¸­';
            const queueText = Number.isInteger(state.queue_position) && state.queue_position >= 0 && !['completed','failed'].includes(status)
                ? ` Â· æ’é˜Ÿ${state.queue_position + 1}`
                : '';
            const errorText = status === 'failed' && state.error ? ` Â· ${state.error}` : '';

            container.innerHTML = `
                <div class="progress-track">
                    <div class="progress-fill" style="width:${progressVal}%; background:${color};"></div>
                </div>
                <div class="progress-meta">
                    <span>${statusText}${queueText}${errorText}</span>
                    <span>${progressVal}%</span>
                </div>
            `;
            container.style.display = 'block';
        }

        function refreshAssemblyStates() {
            Object.entries(PROJECT_GROUPS).forEach(([pid, group]) => {
                renderProjectAssemblyStatus(group.name, pid);
            });
        }

        function refreshAssemblyUIForProject(projectName) {
            const key = getProjectKey(projectName);
            Object.entries(PROJECT_GROUPS).forEach(([pid, group]) => {
                if (getProjectKey(group.name) === key) {
                    renderProjectAssemblyStatus(group.name, pid);
                }
            });
        }

        function stopAssemblyPolling(taskId) {
            delete TASKS_STREAM_SUBS[taskId];
            // æ— è®¢é˜…æ—¶å…³é—­ SSE
            if (TASKS_STREAM_SOURCE && Object.keys(TASKS_STREAM_SUBS).length === 0) {
                try { TASKS_STREAM_SOURCE.close(); } catch (e) {}
                TASKS_STREAM_SOURCE = null;
            }
        }

        function startAssemblyPolling(projectName, taskId) {
            stopAssemblyPolling(taskId);
            TASKS_STREAM_SUBS[taskId] = projectName;
            ensureTasksStreamConnected();
        }

        async function loadMyDocuments() {
            const container = document.getElementById('doc-list-container');
            container.innerHTML = 'åŠ è½½ä¸­...';
            SELECTED_DOCS = new Set();
            
            try {
                // Parallel fetch documents and statuses
                const [resDocs, resStatus] = await Promise.all([
                    apiFetch('/api/documents/my/documents', { headers: getHeaders() }),
                    apiFetch('/api/projects/assembly-status', { headers: getHeaders() })
                ]);

                // Process Statuses first
                if (resStatus.ok) {
                    const dataStatus = await resStatus.json().catch(() => ({}));
                    if (dataStatus.code === 200 && dataStatus.data) {
                        Object.entries(dataStatus.data).forEach(([pName, info]) => {
                            const key = getProjectKey(pName);
                            const current = PROJECT_ASSEMBLY_STATE[key] || {};
                            // Only override if not currently running locally to avoid jitter
                            if (current.status !== 'running' && current.status !== 'queued') {
                                updateProjectAssemblyState(pName, {
                                    status: info.status,
                                    assembly_type: info.assembly_type
                                });
                            }
                        });
                    }
                }

                const data = await resDocs.json();
                if (resDocs.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                
                if (resDocs.ok && data.code === 200) {
                    let docs = (data.data && data.data.documents) ? data.data.documents : [];
                    // è¿‡æ»¤æ‰ä¸­é—´äº§ç‰©ï¼ˆå¦‚ jsonï¼‰
                    docs = docs.filter(doc => !String(doc.file_name || doc.title || '').toLowerCase().endsWith('.json'));
                    ALL_DOCS = docs;
                    if (docs.length === 0) {
                        container.innerHTML = 'æš‚æ— æ–‡æ¡£ï¼Œè¯·å…ˆä¸Šä¼ ';
                    } else {
                        docs.forEach(doc => SELECTED_DOCS.add(doc.file_path));
                        renderDocTable(docs);
                    }
                } else {
                    container.innerHTML = 'åŠ è½½å¤±è´¥: ' + (data.msg || 'æœªçŸ¥é”™è¯¯');
                }
            } catch (e) {
                container.innerHTML = 'åŠ è½½é”™è¯¯: ' + e.message;
            }
        }

        function renderDocTable(docs) {
            const container = document.getElementById('doc-list-container');
            const grouped = {};
            docs.forEach(doc => {
                const key = doc.project_name || 'æœªåˆ†ç»„é¡¹ç›®';
                if (!grouped[key]) grouped[key] = [];
                grouped[key].push(doc);
            });
            PROJECT_GROUPS = {};

            const search = (document.getElementById('project-search')?.value || '').trim().toLowerCase();
            const entries = Object.entries(grouped).map(([project, items], idx) => {
                const nameLower = (project || '').toLowerCase();
                const match = search ? nameLower.includes(search) : false;
                const score = match ? (100 - nameLower.indexOf(search)) : 0;
                return { project, items, score, idx };
            });
            entries.sort((a, b) => b.score - a.score || a.idx - b.idx);
            const matched = entries.filter(e => e.score > 0).slice(0, PROJECT_TOP_K);
            const rest = entries.filter(e => !matched.includes(e));
            const orderedAll = [...matched, ...rest];
            const totalPages = Math.max(1, Math.ceil(orderedAll.length / PAGE_SIZE));
            if (CURRENT_PAGE > totalPages) CURRENT_PAGE = totalPages;
            const start = (CURRENT_PAGE - 1) * PAGE_SIZE;
            const ordered = orderedAll.slice(start, start + PAGE_SIZE);

            const parts = [];
            ordered.forEach((entry, idx) => {
                const { project, items } = entry;
                const pid = `proj-${idx}`;
                PROJECT_GROUPS[pid] = { name: project, docs: items };
                const allChecked = items.every(d => SELECTED_DOCS.has(d.file_path));

                // Button Logic
                const assemblyState = getProjectAssemblyState(project);
                const isCompleted = assemblyState && assemblyState.status === 'completed';
                const btnText = isCompleted ? 'é‡æ–°æ±‡ç¼–' : 'æ±‡ç¼–é¡¹ç›®';
                const btnStyle = isCompleted 
                    ? 'padding: 7px 18px; font-size: 0.85em; font-weight: 600; min-width:100px; border-radius: 20px; box-shadow:0 4px 12px rgba(245, 158, 11, 0.3); background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); border: none; color: white; letter-spacing: 0.5px; transition: all 0.2s;' 
                    : 'padding: 7px 18px; font-size: 0.85em; font-weight: 600; min-width:100px; border-radius: 20px; box-shadow:0 4px 12px rgba(16,185,129,0.3); background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; color: white; letter-spacing: 0.5px; transition: all 0.2s;';

                parts.push(`
                    <details class="project-block" data-project="${pid}">
                        <summary class="project-summary">
                            <div style="display:flex; align-items:center; justify-content:center;">
                                <input type="checkbox" class="project-checkbox" data-project="${pid}" ${allChecked ? 'checked' : ''} onclick="event.stopPropagation(); toggleProject('${pid}', this.checked)">
                            </div>
                            <div class="project-info" style="display:flex; flex-direction:column; align-items:flex-start; gap:2px;">
                                <span class="project-title">${project}</span>
                                <span class="project-meta">(${items.length} ä¸ªæ–‡æ¡£)</span>
                                <div class="project-progress" id="project-progress-${pid}" aria-label="é¡¹ç›®è¿›åº¦" style="display:none;"></div>
                            </div>
                            <div class="project-actions">
                                <select id="assembly-type-${pid}" class="project-select" onchange="setAssemblyType(this.value)">
                                    <option value="é¡¹ç›®æ¡£æ¡ˆ" ${ASSEMBLY_ACTION === 'é¡¹ç›®æ¡£æ¡ˆ' ? 'selected' : ''}>é¡¹ç›®æ¡£æ¡ˆ</option>
                                    <option value="æ–‡ä¹¦æ¡£æ¡ˆ" ${ASSEMBLY_ACTION === 'æ–‡ä¹¦æ¡£æ¡ˆ' ? 'selected' : ''}>æ–‡ä¹¦æ¡£æ¡ˆ</option>
                                    <option value="ç ”ç©¶æ¡£æ¡ˆ" ${ASSEMBLY_ACTION === 'ç ”ç©¶æ¡£æ¡ˆ' ? 'selected' : ''}>ç ”ç©¶æ¡£æ¡ˆ</option>
                                </select>
                                <button id="assembly-btn-${pid}" class="btn btn-primary" style="${btnStyle}" onclick="event.stopPropagation(); handleProjectAssembly('${pid}')">${btnText}</button>
                                <button class="btn btn-danger-soft" aria-label="åˆ é™¤æœ¬é¡¹ç›®" title="åˆ é™¤æœ¬é¡¹ç›®" style="padding: 6px 10px; font-size: 0.9em; width:42px; border-radius: 12px;" onclick="event.stopPropagation(); handleProjectDelete('${pid}')">ğŸ—‘ï¸</button>
                            </div>
                        </summary>
                            <div class="project-files">
                                <div class="doc-header">
                                    <div></div>
                                    <div>æ–‡ä»¶å</div>
                                    <div>çŠ¶æ€</div>
                                    <div>è¿›åº¦</div>
                                    <div>åˆ›å»ºæ—¶é—´</div>
                                    <div>æ“ä½œ</div>
                                </div>
                            ${items.map(doc => `
                                <div class="doc-row">
                                    <div><input type="checkbox" class="doc-checkbox" data-id="${doc.id}" data-project="${pid}" data-path="${doc.file_path}" ${SELECTED_DOCS.has(doc.file_path) ? 'checked' : ''}></div>
                                    <div class="doc-name">${doc.file_name || doc.title || 'æœªå‘½å'}</div>
                                    <div class="doc-status" id="doc-status-${doc.id}">${renderFileStatusBadge('waiting')}</div>
                                    <div class="doc-progress">
                                        <div class="file-progress-track">
                                            <div class="file-progress-fill" id="doc-progress-fill-${doc.id}" style="width:0%;"></div>
                                        </div>
                                        <div class="file-progress-text" id="doc-progress-text-${doc.id}">0%</div>
                                    </div>
                                    <div class="doc-time">${doc.created_at ? new Date(doc.created_at).toLocaleString() : '-'}</div>
                                    <div><button class="btn btn-secondary" style="padding:4px 8px; font-size:0.85em;" data-id="${doc.id}" data-pid="${pid}" data-path="${encodeURIComponent(doc.file_path || '')}" onclick="handleDeleteClick(event)">åˆ é™¤</button></div>
                                </div>
                            `).join('')}
                        </div>
                    </details>
                `);
            });

            container.innerHTML = parts.join('');

            // Bind checkbox events
            container.querySelectorAll('.doc-checkbox').forEach(cb => {
                cb.addEventListener('change', (e) => toggleDoc(e.target.dataset.project, e.target.dataset.path, e.target.checked));
            });

            // æ§åˆ¶åŒæ—¶å±•å¼€çš„æŠ½å±‰æ•°é‡ï¼ˆæ¡Œé¢ 2 ä¸ªï¼Œå°å± 1 ä¸ªï¼‰
            const maxOpen = () => (window.innerWidth < 1280 ? 1 : 2);
            const enforceOpenLimit = () => {
                const openDetails = Array.from(container.querySelectorAll('details.project-block[open]'));
                if (openDetails.length > maxOpen()) {
                    // ä¿ç•™æœ€è¿‘å±•å¼€çš„ï¼Œå…³é—­å¤šä½™çš„
                    openDetails.slice(0, openDetails.length - maxOpen()).forEach(d => d.removeAttribute('open'));
                }
            };
            container.querySelectorAll('details.project-block').forEach(det => {
                det.addEventListener('toggle', () => {
                    if (det.open) enforceOpenLimit();
                });
            });
            enforceOpenLimit();
            updateProjectCheckboxes();
            renderPagination(totalPages);
            refreshAssemblyStates();
            // åŒæ­¥æ¸²æŸ“æ–‡ä»¶çº§è¿›åº¦ï¼ˆå¦‚æœå·²æœ‰è¿›è¡Œä¸­çš„ taskï¼‰
            Object.values(PROJECT_GROUPS).forEach(group => refreshProjectFileProgress(group.name));
        }

        function renderPagination(totalPages) {
            const container = document.getElementById('pagination-container');
            if (!container) return;
            if (totalPages <= 1) {
                container.innerHTML = '';
                return;
            }
            const prevDisabled = CURRENT_PAGE === 1 ? 'disabled' : '';
            const nextDisabled = CURRENT_PAGE === totalPages ? 'disabled' : '';
            container.innerHTML = `
                <div style="display:flex; align-items:center; gap:10px; justify-content:flex-end;">
                    <button class="btn btn-secondary" ${prevDisabled} onclick="changePage(${CURRENT_PAGE - 1})">ä¸Šä¸€é¡µ</button>
                    <span style="color:#4a5568;">ç¬¬ ${CURRENT_PAGE} / ${totalPages} é¡µ</span>
                    <button class="btn btn-secondary" ${nextDisabled} onclick="changePage(${CURRENT_PAGE + 1})">ä¸‹ä¸€é¡µ</button>
                </div>
            `;
        }

        function changePage(page) {
            if (page < 1) return;
            CURRENT_PAGE = page;
            renderDocTable(ALL_DOCS);
        }

        function refreshDocs() {
            renderDocTable(ALL_DOCS);
        }

        function toggleDoc(projectId, path, checked) {
            if (checked) {
                SELECTED_DOCS.add(path);
            } else {
                SELECTED_DOCS.delete(path);
            }
            updateProjectCheckboxes();
        }

        function toggleProject(projectId, checked) {
            const container = document.getElementById('doc-list-container');
            container.querySelectorAll(`.doc-checkbox[data-project="${projectId}"]`).forEach(cb => {
                cb.checked = checked;
                if (checked) {
                    SELECTED_DOCS.add(cb.dataset.path);
                } else {
                    SELECTED_DOCS.delete(cb.dataset.path);
                }
            });
            updateProjectCheckboxes();
        }

        function updateProjectCheckboxes() {
            const container = document.getElementById('doc-list-container');
            container.querySelectorAll('.project-block').forEach(block => {
                const pid = block.dataset.project;
                const docs = Array.from(block.querySelectorAll('.doc-checkbox'));
                if (!docs.length) return;
                const allChecked = docs.every(cb => cb.checked);
                block.querySelectorAll(`.project-checkbox[data-project="${pid}"]`).forEach(cb => cb.checked = allChecked);
            });
        }

        // Delete confirmation state
        let pendingDeleteInfo = null;

        function showDeleteConfirm(docId, projectId, path) {
            pendingDeleteInfo = { docId, projectId, path };
            document.getElementById('delete-confirm-msg').textContent = 'ç¡®å®šåˆ é™¤è¯¥æ–‡æ¡£?';
            document.getElementById('delete-confirm-modal').style.display = 'flex';
        }

        function cancelDelete() {
            pendingDeleteInfo = null;
            document.getElementById('delete-confirm-modal').style.display = 'none';
        }

        async function confirmDelete() {
            if (!pendingDeleteInfo) return;
            const { docId, projectId, path } = pendingDeleteInfo;
            document.getElementById('delete-confirm-modal').style.display = 'none';
            pendingDeleteInfo = null;
            await doDeleteDoc(docId, projectId, path);
        }

        async function doDeleteDoc(docId, projectId, path) {
            try {
                const res = await apiFetch(`/api/documents/${docId}`, {
                    method: 'DELETE',
                    headers: getHeaders()
                });
                const data = await res.json().catch(() => ({}));
                if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                if (res.ok && data.code === 200) {
                    showToast('åˆ é™¤æˆåŠŸ', 'success');
                    await loadMyDocuments(); // é‡æ–°æ‹‰å–ï¼Œä¿æŒä¸DB/å­˜å‚¨åŒæ­¥
                } else {
                    showToast(data.msg || 'åˆ é™¤å¤±è´¥', 'error');
                }
            } catch (e) {
                showToast('åˆ é™¤å¤±è´¥: ' + e.message, 'error');
            }
        }

        function handleDeleteClick(event) {
            event.stopPropagation();
            event.preventDefault();
            const btn = event.currentTarget;
            const docId = btn.dataset.id;
            const pid = btn.dataset.pid;
            const path = decodeURIComponent(btn.dataset.path || '');
            showDeleteConfirm(docId, pid, path);
        }

        async function handleProjectDelete(pid) {
            const group = PROJECT_GROUPS[pid];
            if (!group) return showToast('é¡¹ç›®ä¸å­˜åœ¨', 'error');
            const projectName = group.name || 'æœªå‘½åé¡¹ç›®';
            if (!confirm(`ç¡®è®¤åˆ é™¤é¡¹ç›®ã€Œ${projectName}ã€åŠå…¶æ‰€æœ‰ç›¸å…³æ•°æ®ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`)) return;
            try {
                showToast(`æ­£åœ¨åˆ é™¤é¡¹ç›®: ${projectName}`, 'info');
                const res = await apiFetch('/clear', {
                    method: 'POST',
                    headers: {
                        ...getHeaders({ 'Content-Type': 'application/json' })
                    },
                    body: JSON.stringify({ project_name: projectName })
                });
                const data = await res.json().catch(() => ({}));
                if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                if (res.ok && data.code === 200) {
                    showToast(`åˆ é™¤æˆåŠŸ: ${projectName}`, 'success');
                    await loadMyDocuments();
                } else {
                    throw new Error(data.msg || 'åˆ é™¤å¤±è´¥');
                }
            } catch (e) {
                showToast(`åˆ é™¤å¤±è´¥: ${e.message}`, 'error');
            }
        }

        async function handleProjectAssembly(pid) {
            const group = PROJECT_GROUPS[pid];
            if (!group) return showToast('é¡¹ç›®ä¸å­˜åœ¨', 'error');
            // è¯»å–è¯¥é¡¹ç›®radioçš„é€‰æ‹©
            const localType = (() => {
                const select = document.getElementById(`assembly-type-${pid}`);
                return select ? select.value : ASSEMBLY_ACTION;
            })();
            ASSEMBLY_ACTION = localType || ASSEMBLY_ACTION;
            const action = ASSEMBLY_ACTION;
            const projectName = group.name || 'æœªå‘½åé¡¹ç›®';
            const selected = group.docs
                .filter(d => SELECTED_DOCS.has(d.file_path))
                .map(d => d.file_path);
            if (!selected.length) return showToast('è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªæ–‡æ¡£', 'error');
            const existing = getProjectAssemblyState(projectName);
            if (existing?.taskId) stopAssemblyPolling(existing.taskId);
            updateProjectAssemblyState(projectName, {
                status: 'queued',
                progress: 0,
                error: null,
                taskId: null,
                queue_position: -1,
                selected_urls: selected,
                file_progress: {}
            });
            refreshAssemblyUIForProject(projectName);
            refreshProjectFileProgress(projectName);

            try {
                showToast(`å·²æäº¤æ±‡ç¼–: ${projectName}`, 'info');
                const res = await apiFetch('/assembly_doc', {
                    method: 'POST',
                    headers: {
                        ...getHeaders({ 'Content-Type': 'application/json' })
                    },
                    body: JSON.stringify({
                        urls: selected,
                        project_name: projectName,
                        action: action
                    })
                });

                const data = await res.json().catch(() => ({}));
                if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');

                if (res.ok && (data.code === 202 || data.code === 200) && data.data?.task_id) {
                    const taskId = data.data.task_id;
                    updateProjectAssemblyState(projectName, {
                        status: 'queued',
                        progress: data.data.progress ?? 0,
                        taskId,
                        error: null,
                        queue_position: data.data.queue_position ?? -1,
                        selected_urls: selected
                    });
                    refreshAssemblyUIForProject(projectName);
                    // å…ˆç”¨ waiting å ä½ï¼Œéšåç”± /task/{id} æ‹‰å– file_progress å¡«å……
                    refreshProjectFileProgress(projectName);
                    startAssemblyPolling(projectName, taskId);
                } else if (res.ok && data.code === 200) {
                    updateProjectAssemblyState(projectName, {
                        status: 'completed',
                        progress: 100,
                        error: null
                    });
                    refreshAssemblyUIForProject(projectName);
                    showToast('æ„å»ºæˆåŠŸ!', 'success');
                    document.getElementById('assembly-result-card').style.display = 'block';
                    document.getElementById('assembly-result').innerHTML = syntaxHighlight(data.data);
                } else {
                    throw new Error(data.msg || 'æ„å»ºå¤±è´¥');
                }
            } catch (e) {
                updateProjectAssemblyState(projectName, {
                    status: 'failed',
                    progress: 0,
                    error: e.message
                });
                refreshAssemblyUIForProject(projectName);
                showToast('æ„å»ºå¤±è´¥: ' + e.message, 'error');
            }
        }

        async function handleAssembly() {
            const selectedDocs = Array.from(SELECTED_DOCS);
            const action = ASSEMBLY_ACTION;
            const projectName = 'æ‰¹é‡æ±‡ç¼–';
            if (selectedDocs.length === 0) return showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡æ¡£', 'error');
            const finalProjectName = projectName || 'æ‰¹é‡æ±‡ç¼–';
            // ä¸ºæ‰¹é‡æ±‡ç¼–å¤ç”¨é¡¹ç›®è¿›åº¦æ˜¾ç¤º
            const existing = getProjectAssemblyState(finalProjectName);
            if (existing?.taskId) stopAssemblyPolling(existing.taskId);
            updateProjectAssemblyState(finalProjectName, {
                status: 'queued',
                progress: 0,
                error: null,
                taskId: null,
                queue_position: -1,
                selected_urls: selectedDocs,
                file_progress: {}
            });
            refreshAssemblyUIForProject(finalProjectName);

            try {
                showToast(`å·²æäº¤æ±‡ç¼–: ${finalProjectName}`, 'info');
                const res = await apiFetch('/assembly_doc', {
                    method: 'POST',
                    headers: {
                        ...getHeaders({ 'Content-Type': 'application/json' })
                    },
                    body: JSON.stringify({
                        urls: selectedDocs,
                        project_name: finalProjectName,
                        action: action
                    })
                });

                const data = await res.json().catch(() => ({}));
                if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');

                if (res.ok && (data.code === 202 || data.code === 200) && data.data?.task_id) {
                    const taskId = data.data.task_id;
                    updateProjectAssemblyState(finalProjectName, {
                        status: 'queued',
                        progress: data.data.progress ?? 0,
                        taskId,
                        error: null,
                        queue_position: data.data.queue_position ?? -1
                    });
                    refreshAssemblyUIForProject(finalProjectName);
                    startAssemblyPolling(finalProjectName, taskId);
                } else if (res.ok && data.code === 200) {
                    updateProjectAssemblyState(finalProjectName, {
                        status: 'completed',
                        progress: 100,
                        error: null
                    });
                    refreshAssemblyUIForProject(finalProjectName);
                    showToast('æ„å»ºæˆåŠŸ!', 'success');
                    document.getElementById('assembly-result-card').style.display = 'block';
                    document.getElementById('assembly-result').innerHTML = syntaxHighlight(data.data);
                } else {
                    throw new Error(data.msg || 'æ„å»ºå¤±è´¥');
                }
            } catch (e) {
                updateProjectAssemblyState(finalProjectName, {
                    status: 'failed',
                    progress: 0,
                    error: e.message
                });
                refreshAssemblyUIForProject(finalProjectName);
                showToast('æ„å»ºå¤±è´¥: ' + e.message, 'error');
            }
        }

        // Markdown Parser
        const SimpleMarkdown = {
            parse(text) {
                if (!text) return '';
                let html = text
                    // Escape HTML (partial)
                    .replace(/</g, '&lt;').replace(/>/g, '&gt;')
                    // Headers
                    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                    // Bold
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    // Italic
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    // Code blocks
                    .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
                    // Inline code
                    .replace(/`([^`]+)`/g, '<code>$1</code>')
                    // Blockquote
                    .replace(/^> (.*$)/gim, '<blockquote>$1</blockquote>')
                    // Lists (Basic) - wraps in ul at the end if needed, but for now just lines
                    .replace(/^\s*[\-\*] (.*)/gim, '<li>$1</li>')
                    // Line breaks
                    .replace(/\n/g, '<br>');
                
                // Wrap adjacent lis in ul (simple heuristic)
                html = html.replace(/(<li>.*<\/li>\s*)+/g, '<ul>$&</ul>');
                
                return html;
            }
        };

        function syntaxHighlight(json) {
            if (typeof json != 'string') {
                 json = JSON.stringify(json, undefined, 2);
            }
            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                var cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }

        // Chat
        function clearChat() {
            if(confirm('ç¡®å®šè¦æ¸…ç©ºå¯¹è¯è®°å½•å—ï¼Ÿ')) {
                const container = document.getElementById('chat-messages');
                container.innerHTML = '';
                CHAT_HISTORY.length = 0;
                addMessage('ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„æ™ºèƒ½åŠ©æ‰‹ã€‚è¯·é—®æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®ä½ çš„å—ï¼Ÿæ‚¨å¯ä»¥è¯¢é—®å…³äºå·²ä¸Šä¼ æ–‡æ¡£çš„å†…å®¹ã€‚', 'bot', false, '', false);
            }
        }

        let CHAT_IS_PROCESSING = false;

        const CHAT_ACTION_ICONS = {
            clipboard: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.1665 2.91663C1.1665 1.95013 1.95001 1.16663 2.9165 1.16663H7.58317C8.54967 1.16663 9.33317 1.95013 9.33317 2.91663V3.49996C9.33317 3.82213 9.072 4.08329 8.74984 4.08329C8.42767 4.08329 8.1665 3.82213 8.1665 3.49996V2.91663C8.1665 2.59446 7.90534 2.33329 7.58317 2.33329H2.9165C2.59434 2.33329 2.33317 2.59446 2.33317 2.91663V7.58329C2.33317 7.90546 2.59434 8.16663 2.9165 8.16663H3.49984C3.822 8.16663 4.08317 8.42779 4.08317 8.74996C4.08317 9.07213 3.822 9.33329 3.49984 9.33329H2.9165C1.95001 9.33329 1.1665 8.54979 1.1665 7.58329V2.91663ZM4.6665 6.41663C4.6665 5.45013 5.45001 4.66663 6.4165 4.66663H11.0832C12.0497 4.66663 12.8332 5.45013 12.8332 6.41663V11.0833C12.8332 12.0498 12.0497 12.8333 11.0832 12.8333H6.4165C5.45001 12.8333 4.6665 12.0498 4.6665 11.0833V6.41663ZM6.4165 5.83329C6.09434 5.83329 5.83317 6.09446 5.83317 6.41663V11.0833C5.83317 11.4055 6.09434 11.6666 6.4165 11.6666H11.0832C11.4053 11.6666 11.6665 11.4055 11.6665 11.0833V6.41663C11.6665 6.09446 11.4053 5.83329 11.0832 5.83329H6.4165Z" fill="currentColor"></path></svg>`,
            regenerate: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none"><path d="M8.433.88a.6.6 0 0 1 .846.058L11.2 3.145a.598.598 0 0 1-.102.892L8.86 5.67a.6.6 0 1 1-.707-.969l1.17-.854A6 6 0 0 0 8 3.7a5.18 5.18 0 0 0-5.18 5.18 5.18 5.18 0 1 0 10.36.007.6.6 0 1 1 1.2 0A6.38 6.38 0 1 1 1.62 8.88 6.38 6.38 0 0 1 8 2.5q.59.002 1.124.089l-.75-.862A.6.6 0 0 1 8.433.88" fill="currentColor"></path></svg>`
        };

        function escapeHtml(str) {
            return String(str || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function normalizeSourcePath(fileUrl) {
            if (!fileUrl) return '';
            const raw = String(fileUrl).trim();
            if (!raw) return '';
            try {
                const u = new URL(raw);
                return (u.pathname || '').replace(/^\//, '');
            } catch (_) {
                return raw.replace(/^\//, '');
            }
        }

        function buildFileUrlForPreview(fileUrl) {
            const path = normalizeSourcePath(fileUrl);
            if (!path) return '';
            if (!CURRENT_TOKEN) return '';
            // ä½¿ç”¨ /download ä½œä¸ºç»Ÿä¸€å…¥å£ï¼šç”Ÿäº§ç¯å¢ƒé€šå¸¸å·²æ”¾è¡Œè¯¥è·¯ç”±ï¼›
            // inline=1 ä¾¿äº iframe é¢„è§ˆï¼Œas_pdf=1 ä¾¿äº Office æ–‡æ¡£è½¬æ¢ä¸º PDFï¼ˆåç«¯æ”¯æŒæ—¶ç”Ÿæ•ˆï¼‰ã€‚
            return buildUrl(`/download?url=${encodeURIComponent('/' + path)}&token=${encodeURIComponent(CURRENT_TOKEN)}&inline=1&as_pdf=1`);
        }

        function buildPdfJsViewerUrl(fileUrl, pageNum) {
            const file = buildFileUrlForPreview(fileUrl);
            if (!file) return '';
            const pn = Number(pageNum);
            const viewer = `libs/pdfjs/web/viewer.html?file=${encodeURIComponent(file)}`;
            return Number.isFinite(pn) && pn > 0 ? `${viewer}#page=${pn}` : viewer;
        }

        function toggleDocDrawer(open) {
            const drawer = document.getElementById('doc-drawer');
            const overlay = document.getElementById('doc-overlay');
            if (!drawer || !overlay) return;
            if (open) {
                overlay.style.display = 'block';
                drawer.classList.add('open');
            } else {
                overlay.style.display = 'none';
                drawer.classList.remove('open');
                const iframe = document.getElementById('doc-preview-iframe');
                if (iframe) iframe.src = 'about:blank';
            }
        }

        function openDocPreview({ label, fileUrl, pageNum }) {
            const titleEl = document.getElementById('doc-drawer-title');
            const metaEl = document.getElementById('doc-drawer-meta');
            const iframe = document.getElementById('doc-preview-iframe');
            if (!iframe) return;

            const viewerUrl = buildPdfJsViewerUrl(fileUrl, pageNum);
            if (!viewerUrl) {
                showToast('æ— æ³•é¢„è§ˆï¼šè¯·å…ˆç™»å½•æˆ–æ¥æºç¼ºå¤±', 'error');
                return;
            }

            if (titleEl) titleEl.textContent = label || 'æ–‡æ¡£é¢„è§ˆ';
            const pn = Number(pageNum);
            if (metaEl) metaEl.textContent = `${normalizeSourcePath(fileUrl)}${Number.isFinite(pn) && pn > 0 ? ` Â· ç¬¬ ${pn} é¡µ` : ''}`;

            iframe.src = viewerUrl;
            toggleDocDrawer(true);
        }

        function renderSourceLinksHtml(refs) {
            if (!Array.isArray(refs) || refs.length === 0) return '';
            return `
                <div class="source-docs">
                    <div class="source-docs-title">
                        <span>ğŸ“š</span> å‚è€ƒæ¥æº
                    </div>
                    ${refs.map(r => {
                        const label = r?.label || '';
                        const fileUrl = r?.file_url || '';
                        const pageNum = r?.page_num ?? '';
                        return `
                            <div class="source-item">
                                <span class="source-icon">â€¢</span>
                                <a href="#" class="source-link" data-file-url="${escapeHtml(fileUrl)}" data-page-num="${escapeHtml(pageNum)}" data-label="${escapeHtml(label)}">${escapeHtml(label)}</a>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function renderSourceTextHtml(docs) {
            if (!Array.isArray(docs) || docs.length === 0) return '';
            return `
                <div class="source-docs">
                    <div class="source-docs-title">
                        <span>ğŸ“š</span> å‚è€ƒæ¥æº
                    </div>
                    ${docs.map(s => `
                        <div class="source-item">
                            <span class="source-icon">â€¢</span>
                            <span>${escapeHtml(s)}</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        async function copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
                showToast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
            } catch (err) {
                try {
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.left = '-9999px';
                    document.body.appendChild(textarea);
                    textarea.focus();
                    textarea.select();
                    document.execCommand('copy');
                    textarea.remove();
                    showToast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                } catch (e) {
                    console.error('å¤åˆ¶å¤±è´¥:', err);
                    showToast('å¤åˆ¶å¤±è´¥', 'error');
                }
            }
        }

        function ensureBotActions(msgDiv) {
            let actions = msgDiv.querySelector('.msg-actions');
            if (!actions) {
                actions = document.createElement('div');
                actions.className = 'msg-actions';
                actions.innerHTML = `
                    <button class="msg-action copy" data-action="copy" type="button" title="å¤åˆ¶å“åº”å†…å®¹" aria-label="å¤åˆ¶å“åº”å†…å®¹">${CHAT_ACTION_ICONS.clipboard}</button>
                    <button class="msg-action resend" data-action="resend" type="button" title="é‡æ–°å‘é€åŒä¸€é—®é¢˜" aria-label="é‡æ–°å‘é€åŒä¸€é—®é¢˜">${CHAT_ACTION_ICONS.regenerate}</button>
                `;
                msgDiv.appendChild(actions);
            }
            const resendBtn = actions.querySelector('button.msg-action.resend');
            if (resendBtn) {
                const hasQuestion = !!getAssociatedQuestion(msgDiv);
                resendBtn.style.display = hasQuestion ? '' : 'none';
            }
            return actions;
        }

        function setBotActionsEnabled(msgDiv, enabled) {
            const actions = ensureBotActions(msgDiv);
            actions.querySelectorAll('button.msg-action').forEach(btn => {
                btn.disabled = !enabled;
            });
        }

        function ensureThinkPanel(msgDiv) {
            let panel = msgDiv.querySelector('details.think-panel');
            if (!panel) {
                panel = document.createElement('details');
                panel.className = 'think-panel';
                panel.dataset.placeholderThink = '1';
                panel.innerHTML = `
                    <summary><span>ğŸ§ </span><span>æ€è€ƒè¿‡ç¨‹</span></summary>
                    <pre class="think-content"></pre>
                `;
                msgDiv.insertBefore(panel, msgDiv.firstChild);
            }
            return panel;
        }

        function setThinkPanel(msgDiv, thinkText, { placeholder } = { placeholder: false }) {
            const panel = ensureThinkPanel(msgDiv);
            const pre = panel.querySelector('.think-content');
            if (pre) pre.innerHTML = escapeHtml(thinkText || '');
            if (placeholder) {
                panel.dataset.placeholderThink = '1';
            } else {
                delete panel.dataset.placeholderThink;
            }
        }

        function finalizeThinkPanel(msgDiv, thinkText) {
            const panel = msgDiv.querySelector('details.think-panel');
            if (!thinkText && panel?.dataset?.placeholderThink === '1') {
                panel.remove();
                return;
            }
            if (thinkText) {
                setThinkPanel(msgDiv, thinkText, { placeholder: false });
            }
        }

        function getAssociatedQuestion(msgDiv) {
            const direct = msgDiv?.dataset?.question;
            if (direct) return direct;
            let prev = msgDiv?.previousElementSibling;
            while (prev) {
                if (prev.classList?.contains('message') && prev.classList?.contains('user')) {
                    return prev.textContent.trim();
                }
                prev = prev.previousElementSibling;
            }
            return '';
        }

        async function resendMessage(botMessageId) {
            if (CHAT_IS_PROCESSING) return;
            const msgDiv = document.getElementById(botMessageId);
            if (!msgDiv) return;
            const question = getAssociatedQuestion(msgDiv);
            if (!question) {
                showToast('æœªæ‰¾åˆ°å…³è”é—®é¢˜ï¼Œæ— æ³•é‡å‘', 'error');
                return;
            }
            await runRagStream(question, msgDiv);
        }

        async function runRagStream(question, msgDiv) {
            CHAT_IS_PROCESSING = true;
            try {
                msgDiv.dataset.question = question;
                msgDiv.dataset.answer = '';
                msgDiv.innerHTML = '<div class="markdown-content answer-content">æ€è€ƒä¸­...</div><div class="sources-content"></div>';
                setThinkPanel(msgDiv, '', { placeholder: true });
                setBotActionsEnabled(msgDiv, false);
                const answerDiv = msgDiv.querySelector('.answer-content');
                const sourcesDiv = msgDiv.querySelector('.sources-content');

                const response = await apiFetch('/explain_query_stream', {
                    method: 'POST',
                    headers: {
                        ...getHeaders({ 'Content-Type': 'application/json' })
                    },
                    body: JSON.stringify({
                        question,
                        prompt: "è‡ªå®šä¹‰æ±‡ç¼–",
                        promptName: "è‡ªå®šä¹‰æ±‡ç¼–"
                    })
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                        return;
                    }
                    let errMsg = 'Network error';
                    try {
                        const errData = await response.json();
                        errMsg = errData.detail?.message || errData.detail || errMsg;
                    } catch (_) {}
                    throw new Error(errMsg);
                }

                // Setup stream reader
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let accumulatedText = '';
                let sourceHtml = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    for (const line of lines) {
                        if (!line.trim()) continue;
                        try {
	                            const data = JSON.parse(line);
	                            if (data.type === 'source') {
	                                const refs = data.refs || [];
	                                const docs = data.data || [];
	                                sourceHtml = refs.length ? renderSourceLinksHtml(refs) : renderSourceTextHtml(docs);
	                                if (sourcesDiv) sourcesDiv.innerHTML = sourceHtml;
	                            } else if (data.type === 'content') {
	                                accumulatedText += data.data;
	                                const { visible, think } = extractThink(accumulatedText);
	                                msgDiv.dataset.answer = visible;
                                if (answerDiv) answerDiv.innerHTML = SimpleMarkdown.parse(visible || '');
                                if (think) setThinkPanel(msgDiv, think, { placeholder: false });

                                const container = document.getElementById('chat-messages');
                                container.scrollTop = container.scrollHeight;
                            } else if (data.type === 'error') {
                                throw new Error(data.content);
                            }
                        } catch (e) {
                            console.warn('Error parsing stream line', e);
                        }
                    }
                }

                // Final render (clean up think tags and sources)
                const { visible, think } = extractThink(accumulatedText);
                msgDiv.dataset.answer = visible;

                if (answerDiv) answerDiv.innerHTML = SimpleMarkdown.parse(visible || '');
                if (sourcesDiv) sourcesDiv.innerHTML = sourceHtml || '';
                finalizeThinkPanel(msgDiv, think);
                ensureBotActions(msgDiv);
                setBotActionsEnabled(msgDiv, true);

                saveConversation(visible, 'assistant');
                CHAT_HISTORY.push({ role: 'assistant', content: visible });
            } catch (e) {
                msgDiv.textContent = 'å‘ç”Ÿé”™è¯¯: ' + e.message;
            } finally {
                CHAT_IS_PROCESSING = false;
            }
        }

	        function bindChatActionHandlers() {
	            const container = document.getElementById('chat-messages');
	            if (!container) return;
	            container.addEventListener('click', async (e) => {
	                const link = e.target.closest('a.source-link');
	                if (link) {
	                    e.preventDefault();
	                    const fileUrl = link.dataset.fileUrl || '';
	                    const pageNum = link.dataset.pageNum || '';
	                    const label = link.dataset.label || link.textContent || 'æ–‡æ¡£é¢„è§ˆ';
	                    openDocPreview({ label, fileUrl, pageNum });
	                    return;
	                }

	                const btn = e.target.closest('button.msg-action');
	                if (!btn) return;
	                const msgDiv = btn.closest('.message.bot');
	                if (!msgDiv) return;

                const action = btn.dataset.action;
                if (action === 'copy') {
                    const text = msgDiv.querySelector('.answer-content')?.innerText
                        || msgDiv.querySelector('.markdown-content')?.innerText
                        || msgDiv.dataset.answer
                        || '';
                    if (!text.trim()) {
                        showToast('æš‚æ— å¯å¤åˆ¶å†…å®¹', 'error');
                        return;
                    }
                    await copyToClipboard(text);
                } else if (action === 'resend') {
                    await resendMessage(msgDiv.id);
                }
	            });
	        }

	        const SMART_SEARCH_STATE = {
	            keyword: '',
	            type: '1',
	            pageNum: 1,
	            pageSize: 10,
	            total: 0,
	            hits: [],
	            loading: false
	        };

	        function renderSmartSearchEmpty(message, sub = 'æ”¯æŒç»¼åˆ/ç²¾ç¡®æœç´¢') {
	            return `
	                <div class="search-empty">
	                    <div class="search-empty-title">${escapeHtml(message)}</div>
	                    <div>${escapeHtml(sub)}</div>
	                </div>
	            `;
	        }

	        function getFilenameFromPath(p) {
	            const clean = normalizeSourcePath(p);
	            if (!clean) return '';
	            const parts = clean.split('/');
	            return parts[parts.length - 1] || clean;
	        }

	        function buildSmartSearchQuery(type, keyword) {
	            if (type === '1') {
	                return {
	                    bool: {
	                        should: [
	                            { match: { 'project_name.text': keyword } },
	                            { match: { content: keyword } }
	                        ],
	                        minimum_should_match: 1
	                    }
	                };
	            }
	            // "ç²¾ç¡®æœç´¢"ï¼šå°½é‡ä½¿ç”¨çŸ­è¯­åŒ¹é…ï¼Œé¿å…å™ªå£°
	            return {
	                bool: {
	                    should: [
	                        { match_phrase: { 'project_name.text': keyword } },
	                        { match_phrase: { content: keyword } }
	                    ],
	                    minimum_should_match: 1
	                }
	            };
	        }

	        function updateSmartSearchUI() {
	            const summary = document.getElementById('smart-search-summary');
	            const resultsEl = document.getElementById('smart-search-results');
	            const pager = document.getElementById('smart-search-pagination');
	            const pageEl = document.getElementById('smart-search-page');
	            const prevBtn = document.getElementById('smart-search-prev');
	            const nextBtn = document.getElementById('smart-search-next');

	            if (!summary || !resultsEl || !pager || !pageEl || !prevBtn || !nextBtn) return;

	            const total = SMART_SEARCH_STATE.total || 0;
	            const pageNum = SMART_SEARCH_STATE.pageNum || 1;
	            const pageSize = SMART_SEARCH_STATE.pageSize || 10;
	            const pageCount = Math.max(1, Math.ceil(total / pageSize));

	            if (!SMART_SEARCH_STATE.keyword) {
	                summary.textContent = '';
	                resultsEl.innerHTML = renderSmartSearchEmpty('è¯·è¾“å…¥å…³é”®å­—å¼€å§‹æœç´¢', 'è¾“å…¥å…³é”®å­—åç‚¹å‡»â€œæœç´¢â€ï¼Œæ”¯æŒç‚¹å‡»æ ‡é¢˜é¢„è§ˆ');
	                pager.style.display = 'none';
	                return;
	            }

	            summary.textContent = SMART_SEARCH_STATE.loading
	                ? 'æœç´¢ä¸­...'
	                : `æœ¬æ¬¡å…±æ£€ç´¢å‡º ${total} æ¡ç»“æœ`;

	            if (SMART_SEARCH_STATE.loading && !SMART_SEARCH_STATE.hits.length) {
	                resultsEl.innerHTML = renderSmartSearchEmpty('æœç´¢ä¸­...', 'è¯·ç¨å€™');
	            } else if (!SMART_SEARCH_STATE.hits.length && !SMART_SEARCH_STATE.loading) {
	                resultsEl.innerHTML = renderSmartSearchEmpty('æ— æœç´¢ç»“æœ', 'å¯å°è¯•æ›´æ¢å…³é”®è¯æˆ–ä½¿ç”¨â€œç²¾ç¡®æœç´¢â€');
	            } else if (SMART_SEARCH_STATE.hits.length) {
	                resultsEl.innerHTML = SMART_SEARCH_STATE.hits.map(hit => {
	                    const src = hit?._source || {};
	                    const titleHtml = hit?.highlight?.['project_name.text']?.[0] || escapeHtml(src.project_name || getFilenameFromPath(src.source || ''));
	                    const bodyHtml = hit?.highlight?.content?.[0] || escapeHtml(src.content || '');
	                    const year = escapeHtml(src.year ?? '');
	                    const action = escapeHtml(src.action ?? '');
	                    const pageNum = src.page_num ?? '';
	                    const fileUrl = src.source || '';
	                    const label = src.project_name || getFilenameFromPath(fileUrl);
	                    const docTypes = Array.isArray(src?.metadata?.doc_type) ? src.metadata.doc_type : [];

	                    return `
	                        <div class="search-res-card">
	                            <div class="search-res-title">
	                                <a href="#" class="doc-preview-link" data-file-url="${escapeHtml(fileUrl)}" data-page-num="${escapeHtml(pageNum)}" data-label="${escapeHtml(label)}">${titleHtml}</a>
	                            </div>
	                            <div class="search-res-body">${bodyHtml}</div>
	                            <div class="search-res-footer">
	                                ${year ? `<span>${year}</span>` : ''}
	                                ${action ? `<span class="search-res-tag">${action}</span>` : ''}
	                                ${docTypes.map(t => `<span class="search-res-tag">${escapeHtml(t)}</span>`).join('')}
	                            </div>
	                        </div>
	                    `;
	                }).join('');
	            }

	            pager.style.display = total > 0 ? 'flex' : 'none';
	            pageEl.textContent = `ç¬¬ ${pageNum} / ${pageCount} é¡µ`;
	            prevBtn.disabled = pageNum <= 1 || SMART_SEARCH_STATE.loading;
	            nextBtn.disabled = pageNum >= pageCount || SMART_SEARCH_STATE.loading;
	        }

	        async function performSmartSearch(page = 1) {
	            const input = document.getElementById('smart-search-keyword');
	            const typeSel = document.getElementById('smart-search-type');
	            if (!input || !typeSel) return;

	            const keyword = input.value.trim();
	            const type = typeSel.value || '1';
	            if (!keyword) {
	                showToast('è¯·è¾“å…¥å…³é”®å­—', 'error');
	                return;
	            }
	            if (!CURRENT_TOKEN) {
	                showToast('è¯·å…ˆç™»å½•', 'error');
	                return;
	            }

	            SMART_SEARCH_STATE.keyword = keyword;
	            SMART_SEARCH_STATE.type = type;
	            SMART_SEARCH_STATE.pageNum = Math.max(1, Number(page) || 1);
	            SMART_SEARCH_STATE.loading = true;
	            updateSmartSearchUI();

	            try {
	                const query = buildSmartSearchQuery(type, keyword);
	                const from = (SMART_SEARCH_STATE.pageNum - 1) * SMART_SEARCH_STATE.pageSize;

	                const res = await apiFetch('/api/search/docs', {
	                    method: 'POST',
	                    headers: {
	                        ...getHeaders({ 'Content-Type': 'application/json' })
	                    },
	                    body: JSON.stringify({
	                        query,
	                        highlight: {
	                            fields: {
	                                'project_name.text': {},
	                                content: {}
	                            }
	                        },
	                        _source: { excludes: ['embedding'] },
	                        from,
	                        size: SMART_SEARCH_STATE.pageSize
	                    })
	                });

	                if (res.status === 401) {
	                    forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
	                    return;
	                }
	                if (!res.ok) {
	                    const errText = await res.text().catch(() => '');
	                    throw new Error(errText || `HTTP ${res.status}`);
	                }

	                const data = await res.json().catch(() => ({}));
	                SMART_SEARCH_STATE.hits = data?.hits?.hits || [];
	                SMART_SEARCH_STATE.total = data?.hits?.total?.value ?? 0;
	            } catch (e) {
	                console.error(e);
	                showToast('æœç´¢å¤±è´¥: ' + (e?.message || String(e)), 'error');
	                SMART_SEARCH_STATE.hits = [];
	                SMART_SEARCH_STATE.total = 0;
	            } finally {
	                SMART_SEARCH_STATE.loading = false;
	                updateSmartSearchUI();
	            }
	        }

	        function smartSearchPrev() {
	            performSmartSearch(Math.max(1, (SMART_SEARCH_STATE.pageNum || 1) - 1));
	        }
	        function smartSearchNext() {
	            const total = SMART_SEARCH_STATE.total || 0;
	            const pageCount = Math.max(1, Math.ceil(total / (SMART_SEARCH_STATE.pageSize || 10)));
	            performSmartSearch(Math.min(pageCount, (SMART_SEARCH_STATE.pageNum || 1) + 1));
	        }

	        function bindSmartSearchHandlers() {
	            const input = document.getElementById('smart-search-keyword');
	            const resultsEl = document.getElementById('smart-search-results');
	            if (input) {
	                input.addEventListener('keydown', (e) => {
	                    if (e.key === 'Enter') performSmartSearch(1);
	                });
	            }
	            if (resultsEl) {
	                resultsEl.addEventListener('click', (e) => {
	                    const link = e.target.closest('a.doc-preview-link');
	                    if (!link) return;
	                    e.preventDefault();
	                    openDocPreview({
	                        label: link.dataset.label || link.textContent || 'æ–‡æ¡£é¢„è§ˆ',
	                        fileUrl: link.dataset.fileUrl || '',
	                        pageNum: link.dataset.pageNum || ''
	                    });
	                });
	            }
	        }

	        async function saveConversation(content, role) {
	            if (!CURRENT_USER || !CURRENT_USER.user_id) return;
	            try {
                await apiFetch('/auth/conversations/', {
                    method: 'POST',
                    headers: {
                        ...getHeaders({ 'Content-Type': 'application/json' })
                    },
                    body: JSON.stringify({
                        user_id: CURRENT_USER.user_id,
                        role: role,
                        content: content
                    })
                });
            } catch (e) {
                console.warn('ä¿å­˜å¯¹è¯è®°å½•å¤±è´¥', e);
            }
        }

	        async function sendMessage() {
	            if (!CURRENT_TOKEN) {
	                showLoginModal(true);
	                return;
	            }
	            const input = document.getElementById('chat-input');
	            const text = input.value.trim();
	            if (!text) return;

            // Add user message
            addMessage(text, 'user');
            saveConversation(text, 'user'); // Save user message
            input.value = '';

            try {
                if (CHAT_IS_PROCESSING) return;
                const msgDiv = document.createElement('div');
                msgDiv.className = 'message bot';
                msgDiv.id = nextMsgId();
                msgDiv.dataset.question = text;
                msgDiv.innerHTML = '<div class="markdown-content answer-content">æ€è€ƒä¸­...</div><div class="sources-content"></div>';
                setThinkPanel(msgDiv, '', { placeholder: true });
                ensureBotActions(msgDiv);
                setBotActionsEnabled(msgDiv, false);
                document.getElementById('chat-messages').appendChild(msgDiv);
                document.getElementById('chat-messages').scrollTop = document.getElementById('chat-messages').scrollHeight;

                await runRagStream(text, msgDiv);
            } catch (e) {
                showToast('å‘é€å¤±è´¥: ' + e.message, 'error');
            }
        }

        function addMessage(text, type, isMarkdown = false, appendHtml = '', track = true) {
            const container = document.getElementById('chat-messages');
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.id = nextMsgId();

            const contentHtml = isMarkdown ? SimpleMarkdown.parse(text) : text;
            msgDiv.innerHTML = `
                <div class="${isMarkdown ? 'markdown-content' : ''}">${contentHtml}</div>
                ${appendHtml}
            `;

            // ä»…å¯¹â€œå¯æ“ä½œçš„æœºå™¨äººå›å¤â€å±•ç¤ºå¤åˆ¶/é‡å‘æŒ‰é’®ï¼›
            // åˆå§‹æ¬¢è¿è¯­ç­‰ä¸è®¡å…¥å†å²çš„ç³»ç»Ÿæç¤ºä¸å±•ç¤ºæŒ‰é’®ï¼ˆtrack=falseï¼‰ã€‚
            if (type === 'bot' && track) {
                msgDiv.dataset.answer = typeof text === 'string' ? text : '';
                ensureBotActions(msgDiv);
                setBotActionsEnabled(msgDiv, true);
            }
            
            container.appendChild(msgDiv);
            container.scrollTop = container.scrollHeight;

            if (track && (type === 'user' || type === 'bot')) {
                CHAT_HISTORY.push({
                    role: type === 'user' ? 'user' : 'assistant',
                    content: text
                });
            }
            return msgDiv.id;
        }

        document.addEventListener('DOMContentLoaded', () => {
            bindChatActionHandlers();
            bindSmartSearchHandlers();
            updateSmartSearchUI();
        });

    </script>
</body>
</html>
