<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½çŸ¥è¯†åº“ - Agentic RAG</title>
    <style>
        :root {
            --primary-color: #1262af;
            --secondary-color: #0d4f8c;
            --accent-color: #1262af;
            --text-color: #222;
            --bg-color: #f7fafc;
            --sidebar-width: 250px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            min-height: 100vh;
            overflow: auto; /* å…è®¸é¡µé¢æ•´ä½“æ»šåŠ¨ï¼Œé¿å…å†…å±‚æ»šåŠ¨æ¡ */
        }

        /* Dark theme overrides */
        body.dark {
            --bg-color: #0b1424;
            --text-color: #e5e7eb;
        }
        body.dark .sidebar {
            background: linear-gradient(180deg, #0b2845 0%, #081b2f 100%);
            box-shadow: 2px 0 10px rgba(0,0,0,0.4);
            color: #e5e7eb;
        }
        body.dark .card { background: #0f1b2b; color: var(--text-color); border: 1px solid #1f2937; }
        body.dark input, body.dark select, body.dark textarea {
            background: #0b1220;
            border-color: #1f2937;
            color: var(--text-color);
        }
        body.dark .data-table th { background: #0b1220; color: #e5e7eb; }
        body.dark .data-table td { color: #cbd5e1; }
        body.dark .upload-area { border-color: #1f3b5b; }

        /* Project list */
        .project-block {
            border: 1px solid #e6f3ea;
            border-radius: 10px;
            background: #fff;
            margin-bottom: 14px;
            overflow: hidden;
        }
body.dark .project-block { background: #0c1b2f; border-color: #243447; }
        .project-summary {
            display: flex;
            align-items: center;
            padding: 12px 14px;
            cursor: pointer;
            gap: 12px;
            background: #f3fbf6;
            list-style: none;
        }
        .project-summary::-webkit-details-marker {
            display: none;
        }
        .project-summary .project-info {
            flex: 1;
            min-width: 0;
        }
        .project-summary .project-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: flex-end;
            margin-left: auto;
        }
        .project-summary .project-actions .project-select,
        .project-summary .project-actions .btn {
            flex-shrink: 0;
        }
body.dark .project-summary { background: #102541; }
        .project-summary-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .project-title {
            font-weight: 700;
            color: var(--accent-color);
        }
        body.dark .project-title { color: #8eb4ff; }
        .project-meta {
            color: #718096;
            font-size: 0.9em;
        }
        .project-files {
            padding: 4px 12px 12px 12px;
        }
        .project-progress {
            width: 100%;
            margin-top: 6px;
        }
        .project-progress .progress-track {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 999px;
            overflow: hidden;
        }
        .project-progress .progress-fill {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #48bb78, #38a169);
            transition: width 0.3s ease, background 0.2s ease;
        }
        .project-progress .progress-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 4px;
            color: #4a5568;
            font-size: 0.85em;
        }
body.dark .project-progress .progress-track { background: #1f2937; }
        body.dark .project-progress .progress-meta { color: #cbd5e1; }
        .doc-header,
        .doc-row {
            display: grid;
            grid-template-columns: 40px 1.6fr 110px 180px 170px 110px;
            align-items: center;
            padding: 8px 6px;
        }
        .doc-header {
            font-weight: 600;
            color: #556987;
            border-bottom: 1px solid #e2e8f0;
        }
        .doc-row {
            border-bottom: 1px solid #edf2f7;
        }
        .doc-row:last-child { border-bottom: none; }
        body.dark .doc-row { border-bottom-color: #1f2937; }
        .doc-title {
            font-weight: 600;
            color: #1f3b5b;
        }
        body.dark .doc-title { color: #dce3ff; }
        .doc-name, .doc-time {
            color: #556987;
            font-size: 0.9em;
        }
        body.dark .doc-name, body.dark .doc-time { color: #cbd5e1; }

        /* æ–‡ä»¶çŠ¶æ€ä¸è¿›åº¦ï¼ˆæ±‡ç¼–è¿‡ç¨‹å¯è§†åŒ–ï¼‰ */
        .doc-status {
            display: flex;
            align-items: center;
        }
        .status-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid transparent;
            white-space: nowrap;
        }
        .status-waiting { background: rgba(113,128,150,0.10); color: #4a5568; border-color: rgba(113,128,150,0.25); }
        .status-processing { background: rgba(66,153,225,0.10); color: #2b6cb0; border-color: rgba(66,153,225,0.25); }
        .status-completed { background: rgba(72,187,120,0.10); color: #276749; border-color: rgba(72,187,120,0.25); }
        .status-failed { background: rgba(245,101,101,0.10); color: #c53030; border-color: rgba(245,101,101,0.25); }
        body.dark .status-waiting { background: rgba(203,213,225,0.10); color: #cbd5e1; border-color: rgba(203,213,225,0.25); }
        body.dark .status-processing { background: rgba(99,179,237,0.12); color: #90cdf4; border-color: rgba(99,179,237,0.22); }
        body.dark .status-completed { background: rgba(72,187,120,0.12); color: #9ae6b4; border-color: rgba(72,187,120,0.22); }
        body.dark .status-failed { background: rgba(245,101,101,0.12); color: #feb2b2; border-color: rgba(245,101,101,0.22); }

        .doc-progress {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .file-progress-track {
            flex: 1;
            height: 8px;
            background: #e2e8f0;
            border-radius: 999px;
            overflow: hidden;
        }
        body.dark .file-progress-track { background: #1f2937; }
        .file-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4299e1, #48bb78);
            transition: width 0.25s ease;
        }
        .file-progress-text {
            width: 40px;
            text-align: right;
            font-size: 12px;
            color: #718096;
        }
        body.dark .file-progress-text { color: #cbd5e1; }
        body.dark #doc-list-container {
            background: #0c1b2f !important;
            border-color: #243447 !important;
        }
        body.dark .doc-header { color: #cbd5e1; border-bottom-color: #243447; }
        body.dark .doc-row { border-bottom-color: #243447; }

        /* Select styling */
        .project-select {
            width: 120px;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid #cbd5e0;
            background: #e6f4ff;
            color: #1f3b5b;
            font-size: 0.9em;
        }
        .project-select:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: 1px;
        }
        body.dark .project-select {
            background: #102541;
            border-color: #243447;
            color: #e5e7eb;
        }
        .btn-danger-soft {
            background: rgba(249,115,22,0.08);
            color: #f97316;
            border: 1px solid rgba(249,115,22,0.35);
            box-shadow: none;
        }
        .btn-danger-soft:hover {
            background: rgba(249,115,22,0.15);
            transform: none;
        }
        .btn-danger-soft:active {
            transform: translateY(0);
        }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            background: linear-gradient(180deg, #1262af 0%, #0d4f8c 100%);
            color: white;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.15);
            transition: background 0.3s, color 0.3s;
        }

        .logo {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 40px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-links {
            list-style: none;
            flex: 1;
        }

        .nav-item {
            margin-bottom: 10px;
        }

        .nav-link {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            color: rgba(255,255,255,0.88);
            text-decoration: none;
            border-radius: 10px;
            transition: all 0.25s;
            cursor: pointer;
        }

        .nav-link:hover, .nav-link.active {
            background: rgba(255,255,255,0.18);
            color: white;
            transform: translateX(4px);
        }

        .nav-icon {
            margin-right: 10px;
            font-size: 1.2em;
        }

        .user-profile {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }

        .sidebar-footer {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.15);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .user-info {
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            position: relative;
        }

        .view-section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .view-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .page-header {
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e1e5e9;
        }

        .page-title {
            font-size: 1.8em;
            color: #2d3748;
        }

        /* Cards */
        .card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(15,157,88,0.08);
            margin-bottom: 20px;
            border: 1px solid #e5f4eb;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            border-color: var(--accent-color);
            outline: none;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #0f9d58 0%, #0c7c46 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(15, 157, 88, 0.35);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }

        /* Chat Interface */
        .chat-shell {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: calc(100vh - 220px);
            min-height: 480px;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            background: white;
        }
        body.dark .chat-container {
            background: #0c1b2f;
            border-color: #243447;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
            color: #1f2937;
        }
        body.dark .chat-messages {
            background: #0f1b2b;
            color: #e5e7eb;
        }

        .message {
            margin-bottom: 20px;
            max-width: 80%;
        }

        .message.user {
            margin-left: auto;
            background: #e8f3ff;
            color: #0f172a;
            padding: 12px 18px;
            border-radius: 18px 18px 0 18px;
            border: 1px solid #cbd5e1;
        }
        body.dark .message.user {
            background: #162a42;
            color: #e5e7eb;
            border: 1px solid #243447;
        }

        .message.bot {
            margin-right: auto;
            background: white;
            color: #333;
            padding: 12px 18px;
            border-radius: 18px 18px 18px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        body.dark .message.bot {
            background: #102541;
            color: #e5e7eb;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        }

        .chat-input-area {
            padding: 20px;
            background: white;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 10px;
            position: sticky;
            bottom: 0;
        }
        body.dark .chat-input-area {
            background: #0c1b2f;
            border-top-color: #243447;
        }

        .think-block {
            margin-top: 8px;
            background: #f3f4f6;
            border: 1px dashed #cbd5e0;
            border-radius: 8px;
            padding: 10px;
            font-size: 0.92em;
            color: #374151;
            white-space: pre-wrap;
        }
        body.dark .think-block {
            background: #101a2c;
            border-color: #2c3d55;
            color: #e5e7eb;
        }
        .think-toggle {
            padding: 4px 10px;
            font-size: 0.85em;
        }

        /* History drawer */
        .drawer-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.35);
            display: none;
            z-index: 3000;
        }
        .drawer {
            position: fixed;
            top: 0;
            right: -420px;
            width: 380px;
            height: 100vh;
            background: #ffffff;
            box-shadow: -6px 0 20px rgba(0,0,0,0.2);
            padding: 16px;
            transition: right 0.25s ease;
            z-index: 3001;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .drawer.open {
            right: 0;
        }
        body.dark .drawer {
            background: #0c1b2f;
            color: #e5e7eb;
            box-shadow: -6px 0 20px rgba(0,0,0,0.4);
        }
        .history-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 10px;
            background: #f8fafc;
        }
        body.dark .history-list {
            border-color: #243447;
            background: #0f1b2b;
        }
        .history-item {
            padding: 8px 10px;
            border-bottom: 1px solid #e2e8f0;
        }
        .history-item:last-child {
            border-bottom: none;
        }
        body.dark .history-item {
            border-bottom-color: #243447;
        }
        .history-role {
            font-size: 0.85em;
            color: #4a5568;
            margin-bottom: 4px;
        }
        body.dark .history-role {
            color: #cbd5e1;
        }

        /* File Upload */
        .upload-area {
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: var(--accent-color);
            background: #f7fafc;
        }

        .assembly-result {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
        }
        body.dark .assembly-result {
            background: #0f1b2b;
            color: #e5e7eb;
            border: 1px solid #243447;
        }

        /* Tables */
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th, .data-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .data-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #4a5568;
        }

        .status-badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 500;
        }

        .status-pending { background: #feebc8; color: #c05621; }
        .status-approved { background: #c6f6d5; color: #2f855a; }
        .status-rejected { background: #fed7d7; color: #c53030; }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toast {
            background: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin-bottom: 10px;
            border-left: 4px solid var(--accent-color);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Markdown Content Style */
        .markdown-content { line-height: 1.6; }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 { margin-top: 15px; margin-bottom: 10px; color: #2d3748; }
        .markdown-content p { margin-bottom: 10px; }
        .markdown-content ul, .markdown-content ol { margin-left: 20px; margin-bottom: 10px; }
        .markdown-content li { margin-bottom: 5px; }
        .markdown-content pre { background: #f1f1f1; padding: 12px; border-radius: 6px; overflow-x: auto; margin-bottom: 10px; }
        .markdown-content code { background: #edf2f7; padding: 2px 5px; border-radius: 4px; font-family: monospace; color: #c53030; }
        .markdown-content pre code { background: transparent; padding: 0; color: inherit; }
        .markdown-content blockquote { border-left: 4px solid #cbd5e0; padding-left: 15px; color: #718096; margin-bottom: 10px; }
        
        .source-docs { 
            margin-top: 15px; 
            padding: 12px;
            background: #f7fafc;
            border-radius: 8px;
            border: 1px solid #edf2f7;
            font-size: 0.9em;
        }
        body.dark .source-docs {
            background: #0f1b2b;
            border: 1px solid #243447;
        }
        .source-docs-title {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        body.dark .source-docs-title {
            color: #e0e7ff;
        }
        .source-item {
            display: flex;
            gap: 8px;
            margin-bottom: 5px;
            color: #666;
            line-height: 1.5;
        }
        body.dark .source-item {
            color: #94a3b8;
        }
        .source-icon { 
            color: var(--accent-color);
            font-weight: bold;
        }
        body.dark .source-icon {
            color: #60a5fa;
        }

        /* Assembly Result Pretty Print */
        .json-key { color: #e53e3e; font-weight: bold; }
        .json-string { color: #38a169; }
        .json-number { color: #d69e2e; }
        .json-boolean { color: #3182ce; font-weight: bold; }
        .json-null { color: #718096; font-weight: bold; }
    </style>
</head>
<body>
    <!-- Sidebar -->
        <div class="sidebar">
        <div class="logo" style="display:flex; align-items:center; gap:10px;">
            <img src="image.png" alt="logo" style="width:28px; height:28px; border-radius:6px;"> æ™ºèƒ½çŸ¥è¯†åº“
        </div>
            <ul class="nav-links">
            <li class="nav-item">
                <a class="nav-link active" onclick="switchView('home')">
                    <span class="nav-icon">ğŸ </span> é¦–é¡µ
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link" onclick="switchView('upload')">
                    <span class="nav-icon">ğŸ“¤</span> æ–‡æ¡£ä¸Šä¼ 
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link" onclick="switchView('assembly')">
                    <span class="nav-icon">ğŸ“š</span> çŸ¥è¯†åº“æ„å»º
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link" onclick="switchView('chat')">
                    <span class="nav-icon">ğŸ’¬</span> æ™ºèƒ½é—®ç­”
                </a>
            </li>
        </ul>
        <div class="user-profile">
            <div class="user-info" id="current-user-display">æœªç™»å½•</div>
            <button class="btn btn-secondary" style="width: 100%; font-size: 0.8em;" onclick="showLoginModal()">ç®¡ç†å‘˜ç™»å½•</button>
        </div>
        <div class="sidebar-footer">
            <button class="btn btn-secondary" style="width: 100%; font-size: 0.85em;" onclick="toggleTheme()">
                <span id="theme-toggle-label-sidebar">ğŸŒ™ å¤œé—´</span>
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="toast-container" id="toast-container"></div>

        <!-- Home View -->
        <div id="view-home" class="view-section active">
            <div class="page-header">
                <h1 class="page-title">æ¬¢è¿ä½¿ç”¨æ™ºèƒ½çŸ¥è¯†åº“</h1>
            </div>
            <div class="card">
                <h3>ğŸ‘‹ å¿«é€Ÿå¼€å§‹</h3>
                <p>è¿™æ˜¯ä¸€ä¸ªåŸºäº Agentic RAG çš„å•é¡µé¢åº”ç”¨ï¼Œæä¾›ä»¥ä¸‹åŠŸèƒ½ï¼ˆç®¡ç†å‘˜å…¥å£ï¼‰ï¼š</p>
                <ul style="margin: 20px; line-height: 1.6;">
                    <li><strong>æ–‡æ¡£ä¸Šä¼ </strong>ï¼šä¸Šä¼ PDFã€Wordç­‰æ–‡æ¡£ï¼Œæ”¯æŒOCRè¯†åˆ«ã€‚</li>
                    <li><strong>çŸ¥è¯†åº“æ„å»º</strong>ï¼šé€‰æ‹©æ–‡æ¡£è¿›è¡Œæ±‡ç¼–ï¼Œè‡ªåŠ¨æå–ç»“æ„åŒ–ä¿¡æ¯ã€‚</li>
                    <li><strong>æ™ºèƒ½é—®ç­”</strong>ï¼šåŸºäºçŸ¥è¯†åº“è¿›è¡Œå¤šè½®å¯¹è¯ï¼Œæ”¯æŒæº¯æºã€‚</li>
                </ul>
            </div>
            <div class="card">
                <h3>ğŸ“Š ç³»ç»ŸçŠ¶æ€</h3>
                <div id="system-status" style="margin-bottom: 15px;">æ£€æŸ¥ä¸­...</div>
                
                <div style="border-top: 1px solid #eee; padding-top: 15px;">
                    <label style="font-size: 0.9em; margin-bottom: 5px;">æ¥å£åœ°å€é…ç½®</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="api-base-input" placeholder="ä¾‹å¦‚: http://localhost:18888" style="flex: 1;">
                        <button class="btn btn-primary" style="padding: 8px 15px; font-size: 0.9em;" onclick="updateApiBase()">ä¿å­˜</button>
                    </div>
                    <p style="font-size: 0.8em; color: #718096; margin-top: 5px;">ä¿®æ”¹åå°†è‡ªåŠ¨åˆ·æ–°é¡µé¢ç”Ÿæ•ˆ</p>
                </div>
            </div>
        </div>

        <!-- Upload View -->
        <div id="view-upload" class="view-section">
            <div class="page-header">
                <h1 class="page-title">æ–‡æ¡£ä¸Šä¼ </h1>
            </div>
            <div class="card">
                <form id="upload-form" onsubmit="handleUpload(event)">
                    <div class="form-group">
                        <label>é¡¹ç›®åç§°</label>
                        <input type="text" id="project-name-input" name="title" required placeholder="è¯·è¾“å…¥é¡¹ç›®åç§°">
                    </div>
                    <div class="form-group">
                        <label>ä¸Šä¼ æ–‡ä»¶ï¼ˆä»»æ„ç±»å‹ï¼Œæ”¯æŒå¤šé€‰ï¼›ZIP å°†è‡ªåŠ¨è§£å‹æ‰å¹³åŒ–ï¼‰</label>
                        <div class="upload-area" id="upload-drop-zone">
                            <p>å¯ç‚¹å‡»æˆ–æ‹–æ‹½ï¼Œé€‰æ‹©ä»»æ„æ•°é‡æ–‡ä»¶</p>
                            <input type="file" id="file-input" name="file" multiple style="display: none" onchange="updateFileName(this)">
                            <p id="file-name-display" style="margin-top: 10px; color: #667eea; font-weight: bold;"></p>
                        </div>
                    </div>
                    <button type="submit" class="btn btn-primary">ğŸš€ å¼€å§‹ä¸Šä¼ </button>
                </form>
            </div>
        </div>

        <!-- Assembly View -->
        <div id="view-assembly" class="view-section">
            <div class="page-header" style="display:flex; align-items:center; justify-content:space-between;">
                <h1 class="page-title">çŸ¥è¯†åº“æ„å»º (æ±‡ç¼–)</h1>
            </div>
            <div class="card">
                <div class="form-group">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; justify-content: flex-start;">
                        <input type="text" id="project-search" placeholder="æœç´¢é¡¹ç›®åç§°ï¼ŒåŒ¹é…é¡¹ç½®é¡¶" style="flex:1; min-width: 240px; max-width: 320px; padding: 8px 10px; border: 1px solid #e2e8f0; border-radius: 8px;" oninput="applyProjectSearch()">
                        <button class="btn btn-secondary" style="padding: 8px 12px; font-size: 0.9em;" onclick="applyProjectSearch()">ğŸ” æœç´¢</button>
                    </div>
                    <div style="border: 1px solid #e2e8f0; padding: 10px; border-radius: 8px; background: #f9fafb;" id="doc-list-container">
                        <p style="text-align: center; color: #999;">åŠ è½½ä¸­...</p>
                    </div>
                    <div id="pagination-container" style="margin-top: 10px;"></div>
                </div>
            </div>
            <div class="card" id="assembly-result-card" style="display: none;">
                <h3>æ„å»ºç»“æœ</h3>
                <pre id="assembly-result" class="assembly-result"></pre>
            </div>
        </div>

        <!-- Chat View -->
        <div id="view-chat" class="view-section">
            <div class="page-header" style="display: flex; justify-content: space-between; align-items: center;">
                <h1 class="page-title">æ™ºèƒ½é—®ç­” (RAG)</h1>
                <div style="display:flex; gap:8px;">
                    <button class="btn btn-secondary" style="font-size: 0.8em; padding: 8px 12px;" onclick="toggleHistoryDrawer(true)">
                        ğŸ“œ å†å²
                    </button>
                    <button class="btn btn-secondary" style="font-size: 0.8em; padding: 8px 15px;" onclick="clearChat()">
                        <span>ğŸ—‘ï¸</span> æ¸…ç©ºå¯¹è¯
                    </button>
                </div>
            </div>
            <div class="chat-shell">
                <div class="chat-container">
                    <div class="chat-messages" id="chat-messages"></div>
                    <div class="chat-input-area">
                        <input type="text" id="chat-input" placeholder="è¯·è¾“å…¥æ‚¨çš„é—®é¢˜..." onkeypress="if(event.key === 'Enter') sendMessage()">
                        <button class="btn btn-primary" onclick="sendMessage()">å‘é€</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- History Drawer -->
        <div class="drawer-overlay" id="history-overlay" onclick="toggleHistoryDrawer(false)"></div>
        <div class="drawer" id="history-drawer">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h3 style="margin:0;">å¯¹è¯å†å²</h3>
                <button class="btn btn-secondary" style="padding:4px 10px; font-size:0.85em;" onclick="toggleHistoryDrawer(false)">å…³é—­</button>
            </div>
            <div class="history-list" id="history-list">
                <p style="color:#718096;">æš‚æ— å†å²è®°å½•</p>
            </div>
        </div>

    </div>

    <!-- Login Modal -->
    <div id="login-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center;">
        <div class="card" style="width: 400px;">
            <h3 style="margin-bottom: 20px;">åˆ‡æ¢æ¨¡æ‹Ÿç”¨æˆ·</h3>
            <div class="form-group">
                <label>é€‰æ‹©ç”¨æˆ·è§’è‰²</label>
                <select id="mock-user-select">
                    <option value="1">ç³»ç»Ÿç®¡ç†å‘˜ (admin)</option>
                </select>
            </div>
            <button class="btn btn-primary" style="width: 100%;" onclick="performLogin()">ç™»å½• / ç”ŸæˆToken</button>
            <button class="btn btn-secondary" style="width: 100%; margin-top: 10px;" onclick="document.getElementById('login-modal').style.display='none'">å–æ¶ˆ</button>
        </div>
    </div>

    <!-- Delete Confirm Modal -->
    <div id="delete-confirm-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center;">
        <div class="card" style="width: 380px; text-align: center;">
            <h3 style="margin-bottom: 15px;">âš ï¸ ç¡®è®¤åˆ é™¤</h3>
            <p id="delete-confirm-msg" style="margin-bottom: 20px; color: #4a5568;">ç¡®å®šåˆ é™¤è¯¥æ–‡æ¡£?</p>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="btn btn-secondary" style="flex: 1;" onclick="cancelDelete()">å–æ¶ˆ</button>
                <button class="btn btn-primary" style="flex: 1; background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);" onclick="confirmDelete()">åˆ é™¤</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = resolveApiBase();
        let CURRENT_TOKEN = localStorage.getItem('jwt_token');
        let CURRENT_USER = JSON.parse(localStorage.getItem('user_info') || 'null');

        function resolveApiBase() {
            // Priority: query param override -> localStorage -> global override -> smart default
            const params = new URLSearchParams(window.location.search);
            const override = params.get('api_base') || params.get('api');
            if (override) {
                const clean = sanitizeBase(override);
                localStorage.setItem('rag_api_base', clean);
                return clean;
            }

            // Check localStorage first!
            const stored = localStorage.getItem('rag_api_base');
            if (stored) return sanitizeBase(stored);

            const defaultBase = 'http://localhost:18888';
            const origin = window.location.origin || '';
            const port = window.location.port || '';
            const protocol = window.location.protocol || '';

            const isHttp = protocol.startsWith('http');
            const isFileLike = protocol === 'file:';
            const isAppScheme = protocol.startsWith('app') || origin.startsWith('app://') || origin.startsWith('tauri://');
            const isDevStatic = port === '5180' ||
                origin.includes('localhost:5180') ||
                origin.includes('0.0.0.0:5180') ||
                origin.includes('127.0.0.1:5180');

            // å¯¹äºé http/https æˆ– dev é™æ€æœï¼Œå¼ºåˆ¶é»˜è®¤åç«¯
            if (!isHttp || isFileLike || isAppScheme || isDevStatic) {
                return defaultBase;
            }

            if (window.API_BASE_OVERRIDE) return sanitizeBase(window.API_BASE_OVERRIDE);

            // å…¶ä»–æƒ…å†µç”¨å½“å‰æº
            return sanitizeBase(origin);
        }

        function sanitizeBase(base) {
            if (!base) return '';
            const trimmed = base.endsWith('/') ? base.slice(0, -1) : base;
            // é˜²æ­¢æ— åè®®æˆ–éæ³• scheme å¯¼è‡´ URL æ„é€ æŠ¥é”™
            if (!/^https?:\/\//i.test(trimmed)) {
                return 'http://localhost:18888';
            }
            return trimmed;
        }

        // User Configs (Mock)
        const USER_CONFIGS = {
            '1': { user_id: 1, user_name: 'admin', nick_name: 'ç³»ç»Ÿç®¡ç†å‘˜', dept_id: 100, dept_name: 'æ€»å…¬å¸', roles: ['admin'] },
            '7': { user_id: 7, user_name: 'dev', nick_name: 'å¼€å‘äººå‘˜', dept_id: 105, dept_name: 'æŠ€æœ¯éƒ¨', roles: ['user'] },
            '2': { user_id: 2, user_name: 'dept_admin', nick_name: 'éƒ¨é—¨ç®¡ç†å‘˜', dept_id: 105, dept_name: 'æŠ€æœ¯éƒ¨', roles: ['deptAdmin', 'user'] }
        };
        let CURRENT_THEME = localStorage.getItem('rag_theme') || 'light';

        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('api-base-input').value = API_BASE;
            
            // Auto login as admin if not logged in
            if (!CURRENT_USER) {
                // Mock login as admin by default
                performLogin('1');
            } else {
                updateUserDisplay();
                checkHealth();
            }

            applyTheme(CURRENT_THEME);
            // åˆå§‹æ¬¢è¿è¯­ï¼ˆä¸è®¡å…¥å†å²ï¼‰
            addMessage('ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„æ™ºèƒ½åŠ©æ‰‹ã€‚è¯·é—®æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®ä½ çš„å—ï¼Ÿæ‚¨å¯ä»¥è¯¢é—®å…³äºå·²ä¸Šä¼ æ–‡æ¡£çš„å†…å®¹ã€‚', 'bot', false, '', false);
        });

        // Navigation
        function switchView(viewId) {
            document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
            document.getElementById('view-' + viewId).classList.add('active');
            
            document.querySelectorAll('.nav-link').forEach(el => el.classList.remove('active'));
            event.currentTarget.classList.add('active');

            if (viewId === 'assembly') loadMyDocuments();
            if (viewId === 'upload') setupDragAndDrop();
        }

        // Auth Functions
        function showLoginModal() {
            document.getElementById('login-modal').style.display = 'flex';
        }

        async function performLogin(userIdOverride = null) {
            const userId = userIdOverride || document.getElementById('mock-user-select').value;
            const userConfig = USER_CONFIGS[userId];
            
            try {
                const tokenData = { ...userConfig, expire_minutes: 120 };
                const response = await apiFetch('/api/simple-auth/generate-token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(tokenData)
                });

                if (!response.ok) throw new Error('Login failed');

                const data = await response.json();
                CURRENT_TOKEN = data.token;
                CURRENT_USER = data.user_info;
                CURRENT_USER.user_id = userConfig.user_id; // Ensure user_id is kept

                localStorage.setItem('jwt_token', CURRENT_TOKEN);
                localStorage.setItem('user_info', JSON.stringify(CURRENT_USER));

                updateUserDisplay();
                document.getElementById('login-modal').style.display = 'none';
                showToast('ç™»å½•æˆåŠŸ', 'success');
                checkHealth();
            } catch (e) {
                showToast('ç™»å½•å¤±è´¥: ' + e.message, 'error');
            }
        }

        function updateUserDisplay() {
            if (CURRENT_USER) {
                document.getElementById('current-user-display').innerHTML = `
                    <strong>${CURRENT_USER.nick_name}</strong><br>
                    ${CURRENT_USER.dept_name}
                `;
            }
        }

        // Utils
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.style.borderLeftColor = type === 'error' ? '#f56565' : (type === 'success' ? '#48bb78' : '#4facfe');
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function buildUrl(path) {
            if (path.startsWith('http')) return path;
            return `${API_BASE}${path}`;
        }

        function apiFetch(path, options = {}) {
            return fetch(buildUrl(path), options);
        }

        function getHeaders(extra = {}) {
            const headers = { ...extra };
            if (CURRENT_TOKEN) {
                headers['Authorization'] = `Bearer ${CURRENT_TOKEN}`;
            }
            return headers;
        }

        function forceRelogin(message = 'è¯·é‡æ–°ç™»å½•') {
            localStorage.removeItem('jwt_token');
            localStorage.removeItem('user_info');
            CURRENT_TOKEN = null;
            CURRENT_USER = null;
            showLoginModal();
            showToast(message, 'error');
        }

        function applyTheme(theme) {
            document.body.classList.toggle('dark', theme === 'dark');
            CURRENT_THEME = theme;
            localStorage.setItem('rag_theme', theme);
            const labelSidebar = document.getElementById('theme-toggle-label-sidebar');
            if (labelSidebar) labelSidebar.textContent = theme === 'dark' ? 'â˜€ï¸ æ—¥é—´' : 'ğŸŒ™ å¤œé—´';
        }

        function toggleTheme() {
            const next = CURRENT_THEME === 'dark' ? 'light' : 'dark';
            applyTheme(next);
        }

        // Think tag handling
        function extractThink(text) {
            if (!text) return { visible: text, think: null };
            const regex = /<think>([\s\S]*?)<\/think>/i;
            const match = regex.exec(text);
            if (match) {
                const think = match[1].trim();
                const visible = text.replace(regex, '').trim();
                return { visible, think };
            }
            return { visible: text, think: null };
        }

        function toggleThink(id) {
            const el = document.getElementById(id);
            if (!el) return;
            const isHidden = el.style.display === 'none' || !el.style.display;
            el.style.display = isHidden ? 'block' : 'none';
        }
        
        const CHAT_HISTORY = [];
        let REMOTE_HISTORY = [];
        let USER_ID = null;

        function toggleHistoryDrawer(open) {
            const drawer = document.getElementById('history-drawer');
            const overlay = document.getElementById('history-overlay');
            if (open) {
                loadRemoteHistory().finally(() => renderHistory());
                renderHistory(); // å…ˆç”¨æœ¬åœ°çš„å±•ç¤º
                drawer.classList.add('open');
                overlay.style.display = 'block';
            } else {
                drawer.classList.remove('open');
                overlay.style.display = 'none';
            }
        }

        function renderHistory() {
            const list = document.getElementById('history-list');
            const blocks = [];
            
            // Remote History
            if (REMOTE_HISTORY.length) {
                blocks.push(`<div style="font-weight:700; margin-bottom:6px;">äº‘ç«¯å†å²</div>`);
                
                // Group conversations by proximity in time (sessions)
                const sessions = [];
                let currentSession = [];
                
                // Sort by time ascending first to process
                const sorted = [...REMOTE_HISTORY].sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                
                sorted.forEach((msg, i) => {
                    if (i === 0) {
                        currentSession.push(msg);
                        return;
                    }
                    
                    const prev = sorted[i-1];
                    const timeDiff = new Date(msg.created_at) - new Date(prev.created_at);
                    // Group messages within 5 minutes of each other
                    if (timeDiff < 5 * 60 * 1000) {
                        currentSession.push(msg);
                    } else {
                        if (currentSession.length > 0) sessions.push(currentSession);
                        currentSession = [msg];
                    }
                });
                if (currentSession.length > 0) sessions.push(currentSession);
                
                // Reverse sessions to show newest first
                sessions.reverse().forEach((session, idx) => {
                    // Find first user question in session
                    const userMsg = session.find(m => m.role === 'user');
                    const summary = userMsg ? userMsg.summary : '(æ— æé—®)';
                    const time = new Date(session[0].created_at).toLocaleString();
                    // Store session data in data attribute for restoration
                    const sessionData = encodeURIComponent(JSON.stringify(session));
                    
                    blocks.push(`
                        <div class="history-item" onclick="restoreSession(this)" data-session="${sessionData}" style="cursor:pointer;">
                            <div class="history-role">${time} Â· ä¼šè¯ ${sessions.length - idx}</div>
                            <div style="font-size:0.95em; color:#1f2937;">${summary}</div>
                        </div>
                    `);
                });
            }
            
            // Local History (current active session)
            if (CHAT_HISTORY.length) {
                blocks.push(`<div style="font-weight:700; margin:8px 0 6px 0;">å½“å‰ä¼šè¯</div>`);
                // We don't render individual messages here anymore to avoid clutter,
                // or we could render just a summary "Active Session"
                const lastUserMsg = [...CHAT_HISTORY].reverse().find(m => m.role === 'user');
                const summary = lastUserMsg ? lastUserMsg.content : '(å¯¹è¯è¿›è¡Œä¸­)';
                blocks.push(`
                    <div class="history-item" style="background:#e6fffa; border-left:3px solid #38b2ac;" onclick="toggleHistoryDrawer(false)">
                        <div class="history-role">æ­£åœ¨è¿›è¡Œ</div>
                        <div style="font-size:0.95em; color:#1f2937;">${summary.substring(0, 50)}${summary.length>50?'...':''}</div>
                    </div>
                `);
            }
            
            if (!blocks.length) {
                list.innerHTML = '<p style="color:#718096;">æš‚æ— å†å²è®°å½•</p>';
            } else {
                list.innerHTML = blocks.join('');
            }
        }

        function restoreSession(el) {
            // if (!confirm('æ¢å¤å†å²ä¼šè¯å°†æ¸…ç©ºå½“å‰æœªä¿å­˜çš„å¯¹è¯ç•Œé¢ï¼Œç¡®å®šå—ï¼Ÿ')) return;
            
            try {
                const sessionData = JSON.parse(decodeURIComponent(el.dataset.session));
                const container = document.getElementById('chat-messages');
                container.innerHTML = '';
                CHAT_HISTORY.length = 0; // Clear local history tracking
                
                // Initial greeting
                addMessage('ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„æ™ºèƒ½åŠ©æ‰‹ã€‚è¯·é—®æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®ä½ çš„å—ï¼Ÿæ‚¨å¯ä»¥è¯¢é—®å…³äºå·²ä¸Šä¼ æ–‡æ¡£çš„å†…å®¹ã€‚', 'bot', false, '', false);
                
                // Replay session messages
                sessionData.forEach(msg => {
                    // Map 'assistant' from backend to 'bot' for frontend logic if needed, 
                    // but addMessage handles 'assistant' via CHAT_HISTORY push logic 
                    // strictly speaking addMessage takes 'user' or 'bot' as types for styling.
                    const type = msg.role === 'user' ? 'user' : 'bot';
                    
                    // For bot messages, we might want to render HTML if it was saved that way,
                    // but currently our saveConversation saves the raw content.
                    // Since we use SimpleMarkdown.parse in addMessage, plain text is fine.
                    
                    // Extract think blocks if present in history content (unlikely for now but good for future)
                    let content = msg.summary; // In loadRemoteHistory we mapped content -> summary
                    
                    // If it's bot, handle think tags
                    let thinkHtml = '';
                    if (type === 'bot') {
                        const { visible, think } = extractThink(content);
                        content = visible;
                        if (think) {
                            const thinkId = 'think-hist-' + msg.id;
                            thinkHtml = `
                                <div style="margin-top:8px;">
                                    <button class="btn btn-secondary think-toggle" onclick="toggleThink('${thinkId}')">å±•å¼€æ€è€ƒè¿‡ç¨‹</button>
                                    <div id="${thinkId}" class="think-block" style="display:none;">${think}</div>
                                </div>
                            `;
                        }
                    }
                    
                    addMessage(content, type, type === 'bot', thinkHtml, true);
                });
                
                toggleHistoryDrawer(false);
                showToast('å·²åŠ è½½å†å²ä¼šè¯', 'success');
                
            } catch (e) {
                console.error(e);
                showToast('åŠ è½½ä¼šè¯å¤±è´¥', 'error');
            }
        }

        async function loadRemoteHistory() {
            try {
                // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯ï¼ˆä¸€æ¬¡æ€§ï¼‰
                if (!USER_ID) {
                    const infoRes = await apiFetch('/auth/users/me', { headers: getHeaders() });
                    const infoData = await infoRes.json();
                    if (infoRes.ok && infoData.user_id) {
                        USER_ID = infoData.user_id;
                    }
                }
                if (!USER_ID) return;

                const res = await apiFetch(`/auth/conversations/${USER_ID}?limit=50&skip=0`, {
                    headers: getHeaders()
                });
                const data = await res.json();
                if (res.status === 401) {
                    forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                    return;
                }
                if (res.ok && Array.isArray(data)) {
                    REMOTE_HISTORY = data.map(c => ({
                        id: c.id,
                        created_at: c.timestamp || c.created_at,
                        summary: c.content || '(æ— æé—®)',
                        role: c.role
                    }));
                }
            } catch (e) {
                console.warn('åŠ è½½è¿œç¨‹å†å²å¤±è´¥', e);
            }
        }

        // API Features
        function updateApiBase() {
            const input = document.getElementById('api-base-input');
            let newBase = input.value.trim();
            
            if (!newBase) {
                if(confirm('ç¡®å®šè¦æ¢å¤é»˜è®¤æ¥å£åœ°å€å—ï¼Ÿ')) {
                    localStorage.removeItem('rag_api_base');
                    location.reload();
                }
                return;
            }
            
            // Basic validation and auto-fix
            if (!/^https?:\/\//i.test(newBase)) {
                if (newBase.includes('localhost') || newBase.match(/^\d{1,3}\./)) {
                    newBase = 'http://' + newBase;
                } else {
                    return showToast('æ¥å£åœ°å€å¿…é¡»ä»¥ http:// æˆ– https:// å¼€å¤´', 'error');
                }
            }
            
            // Remove trailing slash
            if (newBase.endsWith('/')) newBase = newBase.slice(0, -1);
            
            if (newBase === API_BASE) return showToast('åœ°å€æœªå‘ç”Ÿå˜åŒ–', 'info');

            localStorage.setItem('rag_api_base', newBase);
            showToast('æ¥å£åœ°å€å·²æ›´æ–°ï¼Œæ­£åœ¨åˆ·æ–°...', 'success');
            setTimeout(() => location.reload(), 800);
        }

        async function checkHealth() {
            try {
                const res = await apiFetch('/health');
                const data = await res.json();
                document.getElementById('system-status').innerHTML = 
                    `æ¥å£: ${API_BASE || 'å½“å‰æº'} Â· çŠ¶æ€: <span class="status-badge status-approved">${data.data.status}</span>`;
            } catch (e) {
                document.getElementById('system-status').innerHTML = `æ¥å£: ${API_BASE || 'å½“å‰æº'} Â· çŠ¶æ€: è¿æ¥å¤±è´¥`;
            }
        }

        function updateFileName(input) {
            if (input.files.length > 0) {
                const names = Array.from(input.files).map(f => f.name);
                document.getElementById('file-name-display').textContent = 'å·²é€‰æ‹©: ' + names.join(', ');
                const projectInput = document.getElementById('project-name-input');
                if (projectInput && !projectInput.value.trim()) {
                    const baseName = names[0].replace(/\.[^/.]+$/, '');
                    projectInput.value = baseName;
                }
            }
        }

        function setupDragAndDrop() {
            const dropZone = document.getElementById('upload-drop-zone');
            const fileInput = document.getElementById('file-input');
            
            if (dropZone.dataset.dndInit) return; // Prevent duplicate listeners
            
            dropZone.addEventListener('click', () => fileInput.click());
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            function highlight(e) {
                dropZone.style.borderColor = 'var(--accent-color)';
                dropZone.style.background = '#f7fafc';
            }

            function unhighlight(e) {
                dropZone.style.borderColor = '#cbd5e0';
                dropZone.style.background = 'transparent';
            }

            dropZone.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (!files || !files.length) return;
                const buffer = new DataTransfer();
                Array.from(files).forEach(f => buffer.items.add(f)); // å…¨éƒ¨ä¿ç•™
                fileInput.files = buffer.files;
                updateFileName(fileInput);
            }
            
            dropZone.dataset.dndInit = 'true';
        }

        // Upload
        async function handleUpload(e) {
            e.preventDefault();
            const projectName = document.getElementById('project-name-input').value.trim();
            const fileInput = document.getElementById('file-input');
            if (!projectName) return showToast('è¯·è¾“å…¥é¡¹ç›®åç§°', 'error');
            if (!fileInput.files.length) return showToast('è¯·é€‰æ‹©æ–‡ä»¶', 'error');

            const files = Array.from(fileInput.files);
            const zipFiles = files.filter(f => f.name.toLowerCase().endsWith('.zip'));
            const otherFiles = files.filter(f => !f.name.toLowerCase().endsWith('.zip'));

            const deptId = (CURRENT_USER && CURRENT_USER.dept_id) ? CURRENT_USER.dept_id : 100;
            
            try {
                let successCount = 0;
                let failed = [];

                if (otherFiles.length) {
                    showToast(`æ­£åœ¨ä¸Šä¼  ${otherFiles.length} ä¸ªæ–‡ä»¶...`, 'info');
                    const formData = new FormData();
                    formData.append('title', projectName);
                    formData.append('department_id', deptId);
                    formData.append('description', '');
                    otherFiles.forEach(f => formData.append('files', f));

                    const res = await apiFetch('/api/documents/upload-multi', {
                        method: 'POST',
                        headers: getHeaders(), // FormData doesn't need Content-Type
                        body: formData
                    });
                    const data = await res.json();
                    if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                    if (!(res.ok && data.code === 200)) {
                        throw new Error(data.msg || 'ä¸Šä¼ å¤±è´¥');
                    }
                    successCount += data?.data?.success || 0;
                    failed = failed.concat(data?.data?.failed || []);
                }

                if (zipFiles.length) {
                    for (const zip of zipFiles) {
                        showToast(`æ­£åœ¨ä¸Šä¼ å¹¶è§£å‹: ${zip.name}`, 'info');
                        const formData = new FormData();
                        formData.append('title', projectName);
                        formData.append('department_id', deptId);
                        formData.append('file', zip);
                        formData.append('description', '');

                        const res = await apiFetch('/api/documents/upload-zip', {
                            method: 'POST',
                            headers: getHeaders(),
                            body: formData
                        });
                        const data = await res.json();
                        if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                        if (!(res.ok && data.code === 200)) {
                            failed.push(zip.name + ': ' + (data.msg || 'ä¸Šä¼ å¤±è´¥'));
                        } else {
                            const count = data?.data?.files?.length || 1;
                            successCount += count;
                        }
                    }
                }

                if (failed.length) {
                    showToast(`éƒ¨åˆ†å¤±è´¥: ${failed.join('ï¼›')}`, 'error');
                }
                if (successCount > 0) {
                    showToast(`ä¸Šä¼ æˆåŠŸï¼Œå¤„ç† ${successCount} ä¸ªæ–‡ä»¶`, 'success');
                }

                e.target.reset();
                document.getElementById('file-name-display').textContent = '';
                document.getElementById('project-name-input').value = '';
            } catch (err) {
                showToast('ä¸Šä¼ å¤±è´¥: ' + err.message, 'error');
            }
        }

        // Assembly
        let ALL_DOCS = [];
        let SELECTED_DOCS = new Set();
        let PROJECT_GROUPS = {};
        const PROJECT_TOP_K = 5;
        let ASSEMBLY_ACTION = 'ç ”ç©¶æ¡£æ¡ˆ';
        const PAGE_SIZE = 12; // æ§åˆ¶æ¯é¡µé¡¹ç›®æ•°ï¼Œä¾¿äºæŠ½å±‰å±•ç¤º
        let CURRENT_PAGE = 1;
        const PROJECT_ASSEMBLY_STATE = {}; // projectKey -> { status, progress, taskId, error, queue_position }
        const ASSEMBLY_POLLERS = {}; // taskId -> intervalId
        const PROJECT_STATUS_LABELS = {
            queued: 'æ’é˜Ÿä¸­',
            running: 'å¤„ç†ä¸­',
            completed: 'å·²å®Œæˆ',
            failed: 'å¤„ç†å¤±è´¥',
            cancelled: 'å·²å–æ¶ˆ',
            timeout: 'è¶…æ—¶'
        };
        let MSG_COUNTER = 0;

        // æ–‡ä»¶çº§è¿›åº¦å±•ç¤ºï¼ˆç¡®è®¤ä¸åç«¯ä¸€è‡´ï¼šwaiting/processing/completed/failedï¼‰
        const FILE_STATUS_LABELS = {
            waiting: 'ç­‰å¾…ä¸­',
            processing: 'å¤„ç†ä¸­',
            completed: 'å·²å®Œæˆ',
            failed: 'å¤±è´¥'
        };
        // å¤ç”¨ tasks.vue çš„ SSE åè®®ï¼šè¿æ¥ /tasks/stream åæŒ‰ task_id è¿‡æ»¤
        let TASKS_STREAM_SOURCE = null;
        const TASKS_STREAM_SUBS = {}; // taskId -> projectName

        function toJsonUrl(filePath) {
            try {
                const raw = decodeURIComponent(String(filePath || ''));
                const noQuery = raw.split('?')[0].split('#')[0];
                if (noQuery.toLowerCase().endsWith('.json')) return noQuery;
                const idx = noQuery.lastIndexOf('.');
                if (idx > -1) return noQuery.slice(0, idx) + '.json';
                return noQuery + '.json';
            } catch (e) {
                const s = String(filePath || '');
                if (s.toLowerCase().endsWith('.json')) return s;
                const idx = s.lastIndexOf('.');
                if (idx > -1) return s.slice(0, idx) + '.json';
                return s + '.json';
            }
        }

        function getFileBadgeClass(status) {
            switch (status) {
                case 'processing': return 'status-processing';
                case 'completed': return 'status-completed';
                case 'failed': return 'status-failed';
                case 'waiting':
                default: return 'status-waiting';
            }
        }

        function renderFileStatusBadge(status) {
            const s = status || 'waiting';
            const text = FILE_STATUS_LABELS[s] || s;
            const cls = getFileBadgeClass(s);
            return `<span class="status-badge ${cls}">${text}</span>`;
        }

        function updateDocProgressRow(docId, fp) {
            const statusEl = document.getElementById(`doc-status-${docId}`);
            const fillEl = document.getElementById(`doc-progress-fill-${docId}`);
            const textEl = document.getElementById(`doc-progress-text-${docId}`);
            if (!statusEl || !fillEl || !textEl) return;
            const status = (fp && fp.status) ? fp.status : 'waiting';
            const progress = Math.min(100, Math.max(0, Number(fp && fp.progress) || 0));
            statusEl.innerHTML = renderFileStatusBadge(status);
            fillEl.style.width = `${progress}%`;
            textEl.textContent = `${progress}%`;
        }

        function refreshProjectFileProgress(projectName) {
            const key = getProjectKey(projectName);
            const state = PROJECT_ASSEMBLY_STATE[key] || {};
            const fpMap = state.file_progress || {};
            const selected = new Set(state.selected_urls || []);

            Object.entries(PROJECT_GROUPS).forEach(([pid, group]) => {
                if (getProjectKey(group.name) !== key) return;
                group.docs.forEach(doc => {
                    const inTask = selected.size ? selected.has(doc.file_path) : true;
                    if (!inTask) {
                        updateDocProgressRow(doc.id, { status: 'waiting', progress: 0 });
                        return;
                    }
                    const jsonUrl = toJsonUrl(doc.file_path);
                    const fp = fpMap[jsonUrl] || { status: 'waiting', progress: 0 };
                    updateDocProgressRow(doc.id, fp);
                });
            });
        }

        function ensureTasksStreamConnected() {
            if (TASKS_STREAM_SOURCE) return;
            const token = CURRENT_TOKEN || localStorage.getItem('jwt_token');
            const url = buildUrl(`/tasks/stream?token=${encodeURIComponent(token || '')}`);
            const es = new EventSource(url);
            TASKS_STREAM_SOURCE = es;

            es.onmessage = function (event) {
                try {
                    const payload = JSON.parse(event.data || '{}');
                    if (payload.error) return;
                    const tasks = Array.isArray(payload.tasks) ? payload.tasks : [];
                    if (!tasks.length) return;

                    // æ„å»ºç´¢å¼•ï¼ŒåŠ é€ŸæŸ¥æ‰¾
                    const byId = {};
                    tasks.forEach(t => { if (t && t.task_id) byId[t.task_id] = t; });

                    Object.entries(TASKS_STREAM_SUBS).forEach(([taskId, projectName]) => {
                        const t = byId[taskId];
                        if (!t) return;

                        const status = t.status || 'running';
                        const progress = status === 'completed' ? 100 : (typeof t.progress === 'number' ? t.progress : 0);
                        updateProjectAssemblyState(projectName, {
                            status,
                            progress,
                            taskId,
                            error: t.error || null,
                            queue_position: t.queue_position ?? -1,
                            estimated_wait: t.estimated_wait ?? 0,
                            file_progress: t.file_progress || {},
                            agent_progress: t.agent_progress || {}
                        });
                        refreshAssemblyUIForProject(projectName);
                        refreshProjectFileProgress(projectName);

                        if (status === 'completed') {
                            showToast('æ±‡ç¼–å®Œæˆ', 'success');
                            loadMyDocuments();
                            delete TASKS_STREAM_SUBS[taskId];
                        } else if (['failed', 'cancelled', 'timeout'].includes(status)) {
                            showToast('æ±‡ç¼–å¤±è´¥: ' + (t.error || 'æœªçŸ¥é”™è¯¯'), 'error');
                            delete TASKS_STREAM_SUBS[taskId];
                        }
                    });

                    // æ— è®¢é˜…æ—¶å…³é—­ SSEï¼Œå‡å°‘è¿æ¥
                    if (Object.keys(TASKS_STREAM_SUBS).length === 0) {
                        try { es.close(); } catch (e) {}
                        TASKS_STREAM_SOURCE = null;
                    }
                } catch (e) {
                    // ignore
                }
            };

            es.onerror = function () {
                // EventSource ä¼šè‡ªåŠ¨é‡è¿ï¼›è‹¥æ²¡æœ‰è®¢é˜…åˆ™å…³é—­
                if (Object.keys(TASKS_STREAM_SUBS).length === 0) {
                    try { es.close(); } catch (e) {}
                    TASKS_STREAM_SOURCE = null;
                }
            };
        }

        function setAssemblyType(val) {
            ASSEMBLY_ACTION = val || 'é¡¹ç›®æ¡£æ¡ˆ';
        }

        function nextMsgId() {
            MSG_COUNTER += 1;
            return `msg-${Date.now().toString(36)}-${MSG_COUNTER}`;
        }

        function getProjectKey(name) {
            return (name || 'æœªåˆ†ç»„é¡¹ç›®').trim();
        }

        function getProjectAssemblyState(projectName) {
            return PROJECT_ASSEMBLY_STATE[getProjectKey(projectName)];
        }

        function updateProjectAssemblyState(projectName, patch) {
            const key = getProjectKey(projectName);
            const prev = PROJECT_ASSEMBLY_STATE[key] || {};
            PROJECT_ASSEMBLY_STATE[key] = { ...prev, ...patch, projectName };
        }

        function getProgressColor(status) {
            if (status === 'failed') return '#f56565';
            if (status === 'completed') return '#48bb78';
            return '#4299e1';
        }

        function renderProjectAssemblyStatus(projectName, pid) {
            const container = document.getElementById(`project-progress-${pid}`);
            const state = getProjectAssemblyState(projectName);
            
            // Update Button State
            const btn = document.getElementById(`assembly-btn-${pid}`);
            if (btn) {
                const status = state ? (state.status || 'running') : 'running';
                const isCompleted = status === 'completed';
                btn.textContent = isCompleted ? 'é‡æ–°æ±‡ç¼–' : 'æ±‡ç¼–é¡¹ç›®';
                
                // Apply optimized styles
                btn.style.padding = '7px 18px';
                btn.style.fontSize = '0.85em';
                btn.style.fontWeight = '600';
                btn.style.minWidth = '100px';
                btn.style.borderRadius = '20px';
                btn.style.border = 'none';
                btn.style.color = 'white';
                btn.style.letterSpacing = '0.5px';
                btn.style.transition = 'all 0.2s';

                if (isCompleted) {
                    btn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
                    btn.style.boxShadow = '0 4px 12px rgba(245, 158, 11, 0.3)';
                } else {
                    btn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                    btn.style.boxShadow = '0 4px 12px rgba(16,185,129,0.3)';
                }
            }

            if (!container) return;
            if (!state) {
                container.style.display = 'none';
                return;
            }
            const status = state.status || 'running';
            // å¦‚æœå·²å®Œæˆï¼Œå¼ºåˆ¶æ˜¾ç¤º100%ï¼›å¦‚æœå¤±è´¥ï¼Œæ˜¾ç¤º0%
            let progressVal = typeof state.progress === 'number' ? Math.min(Math.max(state.progress, 0), 100) : 0;
            if (status === 'completed') {
                progressVal = 100;
            } else if (status === 'failed') {
                progressVal = 0;
            }
            const color = getProgressColor(status);
            const statusText = PROJECT_STATUS_LABELS[status] || 'å¤„ç†ä¸­';
            const queueText = Number.isInteger(state.queue_position) && state.queue_position >= 0 && !['completed','failed'].includes(status)
                ? ` Â· æ’é˜Ÿ${state.queue_position + 1}`
                : '';
            const errorText = status === 'failed' && state.error ? ` Â· ${state.error}` : '';

            container.innerHTML = `
                <div class="progress-track">
                    <div class="progress-fill" style="width:${progressVal}%; background:${color};"></div>
                </div>
                <div class="progress-meta">
                    <span>${statusText}${queueText}${errorText}</span>
                    <span>${progressVal}%</span>
                </div>
            `;
            container.style.display = 'block';
        }

        function refreshAssemblyStates() {
            Object.entries(PROJECT_GROUPS).forEach(([pid, group]) => {
                renderProjectAssemblyStatus(group.name, pid);
            });
        }

        function refreshAssemblyUIForProject(projectName) {
            const key = getProjectKey(projectName);
            Object.entries(PROJECT_GROUPS).forEach(([pid, group]) => {
                if (getProjectKey(group.name) === key) {
                    renderProjectAssemblyStatus(group.name, pid);
                }
            });
        }

        function stopAssemblyPolling(taskId) {
            delete TASKS_STREAM_SUBS[taskId];
            // æ— è®¢é˜…æ—¶å…³é—­ SSE
            if (TASKS_STREAM_SOURCE && Object.keys(TASKS_STREAM_SUBS).length === 0) {
                try { TASKS_STREAM_SOURCE.close(); } catch (e) {}
                TASKS_STREAM_SOURCE = null;
            }
        }

        function startAssemblyPolling(projectName, taskId) {
            stopAssemblyPolling(taskId);
            TASKS_STREAM_SUBS[taskId] = projectName;
            ensureTasksStreamConnected();
        }

        async function loadMyDocuments() {
            const container = document.getElementById('doc-list-container');
            container.innerHTML = 'åŠ è½½ä¸­...';
            SELECTED_DOCS = new Set();
            
            try {
                // Parallel fetch documents and statuses
                const [resDocs, resStatus] = await Promise.all([
                    apiFetch('/api/documents/my/documents', { headers: getHeaders() }),
                    apiFetch('/api/projects/assembly-status', { headers: getHeaders() })
                ]);

                // Process Statuses first
                if (resStatus.ok) {
                    const dataStatus = await resStatus.json().catch(() => ({}));
                    if (dataStatus.code === 200 && dataStatus.data) {
                        Object.entries(dataStatus.data).forEach(([pName, info]) => {
                            const key = getProjectKey(pName);
                            const current = PROJECT_ASSEMBLY_STATE[key] || {};
                            // Only override if not currently running locally to avoid jitter
                            if (current.status !== 'running' && current.status !== 'queued') {
                                updateProjectAssemblyState(pName, {
                                    status: info.status,
                                    assembly_type: info.assembly_type
                                });
                            }
                        });
                    }
                }

                const data = await resDocs.json();
                if (resDocs.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                
                if (resDocs.ok && data.code === 200) {
                    let docs = (data.data && data.data.documents) ? data.data.documents : [];
                    // è¿‡æ»¤æ‰ä¸­é—´äº§ç‰©ï¼ˆå¦‚ jsonï¼‰
                    docs = docs.filter(doc => !String(doc.file_name || doc.title || '').toLowerCase().endsWith('.json'));
                    ALL_DOCS = docs;
                    if (docs.length === 0) {
                        container.innerHTML = 'æš‚æ— æ–‡æ¡£ï¼Œè¯·å…ˆä¸Šä¼ ';
                    } else {
                        docs.forEach(doc => SELECTED_DOCS.add(doc.file_path));
                        renderDocTable(docs);
                    }
                } else {
                    container.innerHTML = 'åŠ è½½å¤±è´¥: ' + (data.msg || 'æœªçŸ¥é”™è¯¯');
                }
            } catch (e) {
                container.innerHTML = 'åŠ è½½é”™è¯¯: ' + e.message;
            }
        }

        function renderDocTable(docs) {
            const container = document.getElementById('doc-list-container');
            const grouped = {};
            docs.forEach(doc => {
                const key = doc.project_name || 'æœªåˆ†ç»„é¡¹ç›®';
                if (!grouped[key]) grouped[key] = [];
                grouped[key].push(doc);
            });
            PROJECT_GROUPS = {};

            const search = (document.getElementById('project-search')?.value || '').trim().toLowerCase();
            const entries = Object.entries(grouped).map(([project, items], idx) => {
                const nameLower = (project || '').toLowerCase();
                const match = search ? nameLower.includes(search) : false;
                const score = match ? (100 - nameLower.indexOf(search)) : 0;
                return { project, items, score, idx };
            });
            entries.sort((a, b) => b.score - a.score || a.idx - b.idx);
            const matched = entries.filter(e => e.score > 0).slice(0, PROJECT_TOP_K);
            const rest = entries.filter(e => !matched.includes(e));
            const orderedAll = [...matched, ...rest];
            const totalPages = Math.max(1, Math.ceil(orderedAll.length / PAGE_SIZE));
            if (CURRENT_PAGE > totalPages) CURRENT_PAGE = totalPages;
            const start = (CURRENT_PAGE - 1) * PAGE_SIZE;
            const ordered = orderedAll.slice(start, start + PAGE_SIZE);

            const parts = [];
            ordered.forEach((entry, idx) => {
                const { project, items } = entry;
                const pid = `proj-${idx}`;
                PROJECT_GROUPS[pid] = { name: project, docs: items };
                const allChecked = items.every(d => SELECTED_DOCS.has(d.file_path));

                // Button Logic
                const assemblyState = getProjectAssemblyState(project);
                const isCompleted = assemblyState && assemblyState.status === 'completed';
                const btnText = isCompleted ? 'é‡æ–°æ±‡ç¼–' : 'æ±‡ç¼–é¡¹ç›®';
                const btnStyle = isCompleted 
                    ? 'padding: 7px 18px; font-size: 0.85em; font-weight: 600; min-width:100px; border-radius: 20px; box-shadow:0 4px 12px rgba(245, 158, 11, 0.3); background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); border: none; color: white; letter-spacing: 0.5px; transition: all 0.2s;' 
                    : 'padding: 7px 18px; font-size: 0.85em; font-weight: 600; min-width:100px; border-radius: 20px; box-shadow:0 4px 12px rgba(16,185,129,0.3); background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; color: white; letter-spacing: 0.5px; transition: all 0.2s;';

                parts.push(`
                    <details class="project-block" data-project="${pid}">
                        <summary class="project-summary">
                            <div style="display:flex; align-items:center; justify-content:center;">
                                <input type="checkbox" class="project-checkbox" data-project="${pid}" ${allChecked ? 'checked' : ''} onclick="event.stopPropagation(); toggleProject('${pid}', this.checked)">
                            </div>
                            <div class="project-info" style="display:flex; flex-direction:column; align-items:flex-start; gap:2px;">
                                <span class="project-title">${project}</span>
                                <span class="project-meta">(${items.length} ä¸ªæ–‡æ¡£)</span>
                                <div class="project-progress" id="project-progress-${pid}" aria-label="é¡¹ç›®è¿›åº¦" style="display:none;"></div>
                            </div>
                            <div class="project-actions">
                                <select id="assembly-type-${pid}" class="project-select" onchange="setAssemblyType(this.value)">
                                    <option value="é¡¹ç›®æ¡£æ¡ˆ" ${ASSEMBLY_ACTION === 'é¡¹ç›®æ¡£æ¡ˆ' ? 'selected' : ''}>é¡¹ç›®æ¡£æ¡ˆ</option>
                                    <option value="æ–‡ä¹¦æ¡£æ¡ˆ" ${ASSEMBLY_ACTION === 'æ–‡ä¹¦æ¡£æ¡ˆ' ? 'selected' : ''}>æ–‡ä¹¦æ¡£æ¡ˆ</option>
                                    <option value="ç ”ç©¶æ¡£æ¡ˆ" ${ASSEMBLY_ACTION === 'ç ”ç©¶æ¡£æ¡ˆ' ? 'selected' : ''}>ç ”ç©¶æ¡£æ¡ˆ</option>
                                </select>
                                <button id="assembly-btn-${pid}" class="btn btn-primary" style="${btnStyle}" onclick="event.stopPropagation(); handleProjectAssembly('${pid}')">${btnText}</button>
                                <button class="btn btn-danger-soft" aria-label="åˆ é™¤æœ¬é¡¹ç›®" title="åˆ é™¤æœ¬é¡¹ç›®" style="padding: 6px 10px; font-size: 0.9em; width:42px; border-radius: 12px;" onclick="event.stopPropagation(); handleProjectDelete('${pid}')">ğŸ—‘ï¸</button>
                            </div>
                        </summary>
                            <div class="project-files">
                                <div class="doc-header">
                                    <div></div>
                                    <div>æ–‡ä»¶å</div>
                                    <div>çŠ¶æ€</div>
                                    <div>è¿›åº¦</div>
                                    <div>åˆ›å»ºæ—¶é—´</div>
                                    <div>æ“ä½œ</div>
                                </div>
                            ${items.map(doc => `
                                <div class="doc-row">
                                    <div><input type="checkbox" class="doc-checkbox" data-id="${doc.id}" data-project="${pid}" data-path="${doc.file_path}" ${SELECTED_DOCS.has(doc.file_path) ? 'checked' : ''}></div>
                                    <div class="doc-name">${doc.file_name || doc.title || 'æœªå‘½å'}</div>
                                    <div class="doc-status" id="doc-status-${doc.id}">${renderFileStatusBadge('waiting')}</div>
                                    <div class="doc-progress">
                                        <div class="file-progress-track">
                                            <div class="file-progress-fill" id="doc-progress-fill-${doc.id}" style="width:0%;"></div>
                                        </div>
                                        <div class="file-progress-text" id="doc-progress-text-${doc.id}">0%</div>
                                    </div>
                                    <div class="doc-time">${doc.created_at ? new Date(doc.created_at).toLocaleString() : '-'}</div>
                                    <div><button class="btn btn-secondary" style="padding:4px 8px; font-size:0.85em;" data-id="${doc.id}" data-pid="${pid}" data-path="${encodeURIComponent(doc.file_path || '')}" onclick="handleDeleteClick(event)">åˆ é™¤</button></div>
                                </div>
                            `).join('')}
                        </div>
                    </details>
                `);
            });

            container.innerHTML = parts.join('');

            // Bind checkbox events
            container.querySelectorAll('.doc-checkbox').forEach(cb => {
                cb.addEventListener('change', (e) => toggleDoc(e.target.dataset.project, e.target.dataset.path, e.target.checked));
            });

            // æ§åˆ¶åŒæ—¶å±•å¼€çš„æŠ½å±‰æ•°é‡ï¼ˆæ¡Œé¢ 2 ä¸ªï¼Œå°å± 1 ä¸ªï¼‰
            const maxOpen = () => (window.innerWidth < 1280 ? 1 : 2);
            const enforceOpenLimit = () => {
                const openDetails = Array.from(container.querySelectorAll('details.project-block[open]'));
                if (openDetails.length > maxOpen()) {
                    // ä¿ç•™æœ€è¿‘å±•å¼€çš„ï¼Œå…³é—­å¤šä½™çš„
                    openDetails.slice(0, openDetails.length - maxOpen()).forEach(d => d.removeAttribute('open'));
                }
            };
            container.querySelectorAll('details.project-block').forEach(det => {
                det.addEventListener('toggle', () => {
                    if (det.open) enforceOpenLimit();
                });
            });
            enforceOpenLimit();
            updateProjectCheckboxes();
            renderPagination(totalPages);
            refreshAssemblyStates();
            // åŒæ­¥æ¸²æŸ“æ–‡ä»¶çº§è¿›åº¦ï¼ˆå¦‚æœå·²æœ‰è¿›è¡Œä¸­çš„ taskï¼‰
            Object.values(PROJECT_GROUPS).forEach(group => refreshProjectFileProgress(group.name));
        }

        function renderPagination(totalPages) {
            const container = document.getElementById('pagination-container');
            if (!container) return;
            if (totalPages <= 1) {
                container.innerHTML = '';
                return;
            }
            const prevDisabled = CURRENT_PAGE === 1 ? 'disabled' : '';
            const nextDisabled = CURRENT_PAGE === totalPages ? 'disabled' : '';
            container.innerHTML = `
                <div style="display:flex; align-items:center; gap:10px; justify-content:flex-end;">
                    <button class="btn btn-secondary" ${prevDisabled} onclick="changePage(${CURRENT_PAGE - 1})">ä¸Šä¸€é¡µ</button>
                    <span style="color:#4a5568;">ç¬¬ ${CURRENT_PAGE} / ${totalPages} é¡µ</span>
                    <button class="btn btn-secondary" ${nextDisabled} onclick="changePage(${CURRENT_PAGE + 1})">ä¸‹ä¸€é¡µ</button>
                </div>
            `;
        }

        function changePage(page) {
            if (page < 1) return;
            CURRENT_PAGE = page;
            renderDocTable(ALL_DOCS);
        }

        function refreshDocs() {
            renderDocTable(ALL_DOCS);
        }

        function toggleDoc(projectId, path, checked) {
            if (checked) {
                SELECTED_DOCS.add(path);
            } else {
                SELECTED_DOCS.delete(path);
            }
            updateProjectCheckboxes();
        }

        function toggleProject(projectId, checked) {
            const container = document.getElementById('doc-list-container');
            container.querySelectorAll(`.doc-checkbox[data-project="${projectId}"]`).forEach(cb => {
                cb.checked = checked;
                if (checked) {
                    SELECTED_DOCS.add(cb.dataset.path);
                } else {
                    SELECTED_DOCS.delete(cb.dataset.path);
                }
            });
            updateProjectCheckboxes();
        }

        function updateProjectCheckboxes() {
            const container = document.getElementById('doc-list-container');
            container.querySelectorAll('.project-block').forEach(block => {
                const pid = block.dataset.project;
                const docs = Array.from(block.querySelectorAll('.doc-checkbox'));
                if (!docs.length) return;
                const allChecked = docs.every(cb => cb.checked);
                block.querySelectorAll(`.project-checkbox[data-project="${pid}"]`).forEach(cb => cb.checked = allChecked);
            });
        }

        // Delete confirmation state
        let pendingDeleteInfo = null;

        function showDeleteConfirm(docId, projectId, path) {
            pendingDeleteInfo = { docId, projectId, path };
            document.getElementById('delete-confirm-msg').textContent = 'ç¡®å®šåˆ é™¤è¯¥æ–‡æ¡£?';
            document.getElementById('delete-confirm-modal').style.display = 'flex';
        }

        function cancelDelete() {
            pendingDeleteInfo = null;
            document.getElementById('delete-confirm-modal').style.display = 'none';
        }

        async function confirmDelete() {
            if (!pendingDeleteInfo) return;
            const { docId, projectId, path } = pendingDeleteInfo;
            document.getElementById('delete-confirm-modal').style.display = 'none';
            pendingDeleteInfo = null;
            await doDeleteDoc(docId, projectId, path);
        }

        async function doDeleteDoc(docId, projectId, path) {
            try {
                const res = await apiFetch(`/api/documents/${docId}`, {
                    method: 'DELETE',
                    headers: getHeaders()
                });
                const data = await res.json().catch(() => ({}));
                if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                if (res.ok && data.code === 200) {
                    showToast('åˆ é™¤æˆåŠŸ', 'success');
                    await loadMyDocuments(); // é‡æ–°æ‹‰å–ï¼Œä¿æŒä¸DB/å­˜å‚¨åŒæ­¥
                } else {
                    showToast(data.msg || 'åˆ é™¤å¤±è´¥', 'error');
                }
            } catch (e) {
                showToast('åˆ é™¤å¤±è´¥: ' + e.message, 'error');
            }
        }

        function handleDeleteClick(event) {
            event.stopPropagation();
            event.preventDefault();
            const btn = event.currentTarget;
            const docId = btn.dataset.id;
            const pid = btn.dataset.pid;
            const path = decodeURIComponent(btn.dataset.path || '');
            showDeleteConfirm(docId, pid, path);
        }

        async function handleProjectDelete(pid) {
            const group = PROJECT_GROUPS[pid];
            if (!group) return showToast('é¡¹ç›®ä¸å­˜åœ¨', 'error');
            const projectName = group.name || 'æœªå‘½åé¡¹ç›®';
            if (!confirm(`ç¡®è®¤åˆ é™¤é¡¹ç›®ã€Œ${projectName}ã€åŠå…¶æ‰€æœ‰ç›¸å…³æ•°æ®ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`)) return;
            try {
                showToast(`æ­£åœ¨åˆ é™¤é¡¹ç›®: ${projectName}`, 'info');
                const res = await apiFetch('/clear', {
                    method: 'POST',
                    headers: {
                        ...getHeaders({ 'Content-Type': 'application/json' })
                    },
                    body: JSON.stringify({ project_name: projectName })
                });
                const data = await res.json().catch(() => ({}));
                if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                if (res.ok && data.code === 200) {
                    showToast(`åˆ é™¤æˆåŠŸ: ${projectName}`, 'success');
                    await loadMyDocuments();
                } else {
                    throw new Error(data.msg || 'åˆ é™¤å¤±è´¥');
                }
            } catch (e) {
                showToast(`åˆ é™¤å¤±è´¥: ${e.message}`, 'error');
            }
        }

        async function handleProjectAssembly(pid) {
            const group = PROJECT_GROUPS[pid];
            if (!group) return showToast('é¡¹ç›®ä¸å­˜åœ¨', 'error');
            // è¯»å–è¯¥é¡¹ç›®radioçš„é€‰æ‹©
            const localType = (() => {
                const select = document.getElementById(`assembly-type-${pid}`);
                return select ? select.value : ASSEMBLY_ACTION;
            })();
            ASSEMBLY_ACTION = localType || ASSEMBLY_ACTION;
            const action = ASSEMBLY_ACTION;
            const projectName = group.name || 'æœªå‘½åé¡¹ç›®';
            const selected = group.docs
                .filter(d => SELECTED_DOCS.has(d.file_path))
                .map(d => d.file_path);
            if (!selected.length) return showToast('è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªæ–‡æ¡£', 'error');
            const existing = getProjectAssemblyState(projectName);
            if (existing?.taskId) stopAssemblyPolling(existing.taskId);
            updateProjectAssemblyState(projectName, {
                status: 'queued',
                progress: 0,
                error: null,
                taskId: null,
                queue_position: -1,
                selected_urls: selected,
                file_progress: {}
            });
            refreshAssemblyUIForProject(projectName);
            refreshProjectFileProgress(projectName);

            try {
                showToast(`å·²æäº¤æ±‡ç¼–: ${projectName}`, 'info');
                const res = await apiFetch('/assembly_doc', {
                    method: 'POST',
                    headers: {
                        ...getHeaders({ 'Content-Type': 'application/json' })
                    },
                    body: JSON.stringify({
                        urls: selected,
                        project_name: projectName,
                        action: action
                    })
                });

                const data = await res.json().catch(() => ({}));
                if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');

                if (res.ok && (data.code === 202 || data.code === 200) && data.data?.task_id) {
                    const taskId = data.data.task_id;
                    updateProjectAssemblyState(projectName, {
                        status: 'queued',
                        progress: data.data.progress ?? 0,
                        taskId,
                        error: null,
                        queue_position: data.data.queue_position ?? -1,
                        selected_urls: selected
                    });
                    refreshAssemblyUIForProject(projectName);
                    // å…ˆç”¨ waiting å ä½ï¼Œéšåç”± /task/{id} æ‹‰å– file_progress å¡«å……
                    refreshProjectFileProgress(projectName);
                    startAssemblyPolling(projectName, taskId);
                } else if (res.ok && data.code === 200) {
                    updateProjectAssemblyState(projectName, {
                        status: 'completed',
                        progress: 100,
                        error: null
                    });
                    refreshAssemblyUIForProject(projectName);
                    showToast('æ„å»ºæˆåŠŸ!', 'success');
                    document.getElementById('assembly-result-card').style.display = 'block';
                    document.getElementById('assembly-result').innerHTML = syntaxHighlight(data.data);
                } else {
                    throw new Error(data.msg || 'æ„å»ºå¤±è´¥');
                }
            } catch (e) {
                updateProjectAssemblyState(projectName, {
                    status: 'failed',
                    progress: 0,
                    error: e.message
                });
                refreshAssemblyUIForProject(projectName);
                showToast('æ„å»ºå¤±è´¥: ' + e.message, 'error');
            }
        }

        async function handleAssembly() {
            const selectedDocs = Array.from(SELECTED_DOCS);
            const action = ASSEMBLY_ACTION;
            const projectName = 'æ‰¹é‡æ±‡ç¼–';
            if (selectedDocs.length === 0) return showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡æ¡£', 'error');
            const finalProjectName = projectName || 'æ‰¹é‡æ±‡ç¼–';
            // ä¸ºæ‰¹é‡æ±‡ç¼–å¤ç”¨é¡¹ç›®è¿›åº¦æ˜¾ç¤º
            const existing = getProjectAssemblyState(finalProjectName);
            if (existing?.taskId) stopAssemblyPolling(existing.taskId);
            updateProjectAssemblyState(finalProjectName, {
                status: 'queued',
                progress: 0,
                error: null,
                taskId: null,
                queue_position: -1,
                selected_urls: selectedDocs,
                file_progress: {}
            });
            refreshAssemblyUIForProject(finalProjectName);

            try {
                showToast(`å·²æäº¤æ±‡ç¼–: ${finalProjectName}`, 'info');
                const res = await apiFetch('/assembly_doc', {
                    method: 'POST',
                    headers: {
                        ...getHeaders({ 'Content-Type': 'application/json' })
                    },
                    body: JSON.stringify({
                        urls: selectedDocs,
                        project_name: finalProjectName,
                        action: action
                    })
                });

                const data = await res.json().catch(() => ({}));
                if (res.status === 401) return forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');

                if (res.ok && (data.code === 202 || data.code === 200) && data.data?.task_id) {
                    const taskId = data.data.task_id;
                    updateProjectAssemblyState(finalProjectName, {
                        status: 'queued',
                        progress: data.data.progress ?? 0,
                        taskId,
                        error: null,
                        queue_position: data.data.queue_position ?? -1
                    });
                    refreshAssemblyUIForProject(finalProjectName);
                    startAssemblyPolling(finalProjectName, taskId);
                } else if (res.ok && data.code === 200) {
                    updateProjectAssemblyState(finalProjectName, {
                        status: 'completed',
                        progress: 100,
                        error: null
                    });
                    refreshAssemblyUIForProject(finalProjectName);
                    showToast('æ„å»ºæˆåŠŸ!', 'success');
                    document.getElementById('assembly-result-card').style.display = 'block';
                    document.getElementById('assembly-result').innerHTML = syntaxHighlight(data.data);
                } else {
                    throw new Error(data.msg || 'æ„å»ºå¤±è´¥');
                }
            } catch (e) {
                updateProjectAssemblyState(finalProjectName, {
                    status: 'failed',
                    progress: 0,
                    error: e.message
                });
                refreshAssemblyUIForProject(finalProjectName);
                showToast('æ„å»ºå¤±è´¥: ' + e.message, 'error');
            }
        }

        // Markdown Parser
        const SimpleMarkdown = {
            parse(text) {
                if (!text) return '';
                let html = text
                    // Escape HTML (partial)
                    .replace(/</g, '&lt;').replace(/>/g, '&gt;')
                    // Headers
                    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                    // Bold
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    // Italic
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    // Code blocks
                    .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
                    // Inline code
                    .replace(/`([^`]+)`/g, '<code>$1</code>')
                    // Blockquote
                    .replace(/^> (.*$)/gim, '<blockquote>$1</blockquote>')
                    // Lists (Basic) - wraps in ul at the end if needed, but for now just lines
                    .replace(/^\s*[\-\*] (.*)/gim, '<li>$1</li>')
                    // Line breaks
                    .replace(/\n/g, '<br>');
                
                // Wrap adjacent lis in ul (simple heuristic)
                html = html.replace(/(<li>.*<\/li>\s*)+/g, '<ul>$&</ul>');
                
                return html;
            }
        };

        function syntaxHighlight(json) {
            if (typeof json != 'string') {
                 json = JSON.stringify(json, undefined, 2);
            }
            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                var cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }

        // Chat
        function clearChat() {
            if(confirm('ç¡®å®šè¦æ¸…ç©ºå¯¹è¯è®°å½•å—ï¼Ÿ')) {
                const container = document.getElementById('chat-messages');
                container.innerHTML = '';
                CHAT_HISTORY.length = 0;
                addMessage('ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„æ™ºèƒ½åŠ©æ‰‹ã€‚è¯·é—®æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®ä½ çš„å—ï¼Ÿæ‚¨å¯ä»¥è¯¢é—®å…³äºå·²ä¸Šä¼ æ–‡æ¡£çš„å†…å®¹ã€‚', 'bot', false, '', false);
            }
        }

        async function saveConversation(content, role) {
            if (!CURRENT_USER || !CURRENT_USER.user_id) return;
            try {
                await apiFetch('/auth/conversations/', {
                    method: 'POST',
                    headers: {
                        ...getHeaders({ 'Content-Type': 'application/json' })
                    },
                    body: JSON.stringify({
                        user_id: CURRENT_USER.user_id,
                        role: role,
                        content: content
                    })
                });
            } catch (e) {
                console.warn('ä¿å­˜å¯¹è¯è®°å½•å¤±è´¥', e);
            }
        }

        async function sendMessage() {
            const input = document.getElementById('chat-input');
            const text = input.value.trim();
            if (!text) return;

            // Add user message
            addMessage(text, 'user');
            saveConversation(text, 'user'); // Save user message
            input.value = '';

            // Loading state
            const loadingId = addMessage('æ€è€ƒä¸­...', 'bot', false, '', false);

            try {
                // Using /explain_query_stream for RAG chat
                const response = await apiFetch('/explain_query_stream', {
                    method: 'POST',
                    headers: {
                        ...getHeaders({ 'Content-Type': 'application/json' })
                    },
                    body: JSON.stringify({
                        question: text,
                        prompt: "è‡ªå®šä¹‰æ±‡ç¼–", 
                        promptName: "è‡ªå®šä¹‰æ±‡ç¼–"
                    })
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        forceRelogin('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
                        return;
                    }
                    let errMsg = 'Network error';
                    try {
                        const errData = await response.json();
                        errMsg = errData.detail?.message || errData.detail || errMsg;
                    } catch (_) {}
                    throw new Error(errMsg);
                }
                
                // Clear loading message content
                const msgDiv = document.getElementById(loadingId);
                msgDiv.innerHTML = '<div class="markdown-content"></div>';
                const contentDiv = msgDiv.querySelector('.markdown-content');
                
                // Setup stream reader
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let accumulatedText = '';
                let sourceHtml = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // Keep last partial line
                    
                    for (const line of lines) {
                        if (!line.trim()) continue;
                        try {
                            const data = JSON.parse(line);
                            if (data.type === 'source') {
                                const docs = data.data || [];
                                if (docs.length > 0) {
                                     sourceHtml = `
                                        <div class="source-docs">
                                            <div class="source-docs-title">
                                                <span>ğŸ“š</span> å‚è€ƒæ¥æº
                                            </div>
                                            ${docs.map(s => `
                                                <div class="source-item">
                                                    <span class="source-icon">â€¢</span>
                                                    <span>${s}</span>
                                                </div>
                                            `).join('')}
                                        </div>
                                    `;
                                }
                            } else if (data.type === 'content') {
                                accumulatedText += data.data;
                                contentDiv.innerHTML = SimpleMarkdown.parse(accumulatedText);
                                
                                // Scroll to bottom
                                const container = document.getElementById('chat-messages');
                                container.scrollTop = container.scrollHeight;
                            } else if (data.type === 'error') {
                                throw new Error(data.content);
                            }
                        } catch (e) {
                            console.warn('Error parsing stream line', e);
                        }
                    }
                }
                
                // Final render (clean up think tags and sources)
                const { visible, think } = extractThink(accumulatedText);
                let finalThinkHtml = '';
                if (think) {
                     const thinkId = 'think-' + Date.now();
                     finalThinkHtml = `
                        <div style="margin-top:8px;">
                            <button class="btn btn-secondary think-toggle" onclick="toggleThink('${thinkId}')">å±•å¼€æ€è€ƒè¿‡ç¨‹</button>
                            <div id="${thinkId}" class="think-block" style="display:none;">${think}</div>
                        </div>
                    `;
                }
                
                msgDiv.innerHTML = `
                    <div class="markdown-content">${SimpleMarkdown.parse(visible)}</div>
                    ${sourceHtml}
                    ${finalThinkHtml}
                `;
                
                // Save bot response
                saveConversation(visible, 'assistant');
                
                // Track in history
                CHAT_HISTORY.push({
                    role: 'assistant',
                    content: visible
                });

            } catch (e) {
                document.getElementById(loadingId).textContent = 'å‘ç”Ÿé”™è¯¯: ' + e.message;
            }
        }

        function addMessage(text, type, isMarkdown = false, appendHtml = '', track = true) {
            const container = document.getElementById('chat-messages');
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.id = nextMsgId();

            const contentHtml = isMarkdown ? SimpleMarkdown.parse(text) : text;
            msgDiv.innerHTML = `
                <div class="${isMarkdown ? 'markdown-content' : ''}">${contentHtml}</div>
                ${appendHtml}
            `;
            
            container.appendChild(msgDiv);
            container.scrollTop = container.scrollHeight;

            if (track && (type === 'user' || type === 'bot')) {
                CHAT_HISTORY.push({
                    role: type === 'user' ? 'user' : 'assistant',
                    content: text
                });
            }
            return msgDiv.id;
        }

    </script>
</body>
</html>
